\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/******************************************************************************\PYGZbs{}}
\PYG{c+cm}{* Copyright (C) 2012\PYGZhy{}2015 Leap Motion, Inc. All rights reserved.               *}
\PYG{c+cm}{* Leap Motion proprietary and confidential. Not for distribution.              *}
\PYG{c+cm}{* Use subject to the terms of the Leap Motion SDK Agreement available at       *}
\PYG{c+cm}{* https://developer.leapmotion.com/sdk\PYGZus{}agreement, or another agreement         *}
\PYG{c+cm}{* between Leap Motion and you, your company or other organization.             *}
\PYG{c+cm}{\PYGZbs{}******************************************************************************/}

\PYG{c+cp}{\PYGZsh{}if !defined(\PYGZus{}\PYGZus{}Leap\PYGZus{}h\PYGZus{}\PYGZus{})}
\PYG{c+cp}{\PYGZsh{}define \PYGZus{}\PYGZus{}Leap\PYGZus{}h\PYGZus{}\PYGZus{}}

\PYG{c+cp}{\PYGZsh{}include} \PYG{c+cpf}{\PYGZdq{}LeapMath.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}include} \PYG{c+cpf}{\PYGZlt{}string\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}include} \PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}include} \PYG{c+cpf}{\PYGZlt{}cstring\PYGZgt{}}

\PYG{c+c1}{// Define integer types for Visual Studio 2008 and earlier}
\PYG{c+cp}{\PYGZsh{}if defined(\PYGZus{}MSC\PYGZus{}VER) \PYGZam{}\PYGZam{} (\PYGZus{}MSC\PYGZus{}VER \PYGZlt{} 1600)}
\PYG{k}{typedef} \PYG{k+kr}{\PYGZus{}\PYGZus{}int32} \PYG{k+kt}{int32\PYGZus{}t}\PYG{p}{;}
\PYG{k}{typedef} \PYG{k+kr}{\PYGZus{}\PYGZus{}int64} \PYG{k+kt}{int64\PYGZus{}t}\PYG{p}{;}
\PYG{k}{typedef} \PYG{k+kt}{unsigned} \PYG{k+kr}{\PYGZus{}\PYGZus{}int32} \PYG{k+kt}{uint32\PYGZus{}t}\PYG{p}{;}
\PYG{k}{typedef} \PYG{k+kt}{unsigned} \PYG{k+kr}{\PYGZus{}\PYGZus{}int64} \PYG{k+kt}{uint64\PYGZus{}t}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}else}
\PYG{c+cp}{\PYGZsh{}include} \PYG{c+cpf}{\PYGZlt{}stdint.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}endif}

\PYG{c+c1}{// Define Leap export macros}
\PYG{c+cp}{\PYGZsh{}if defined(\PYGZus{}MSC\PYGZus{}VER) }\PYG{c+c1}{// Visual C++}
\PYG{c+cp}{\PYGZsh{}if LEAP\PYGZus{}API\PYGZus{}INTERNAL}
\PYG{c+cp}{\PYGZsh{}define LEAP\PYGZus{}EXPORT}
\PYG{c+cp}{\PYGZsh{}elif LEAP\PYGZus{}API\PYGZus{}IMPLEMENTATION}
\PYG{c+cp}{\PYGZsh{}define LEAP\PYGZus{}EXPORT \PYGZus{}\PYGZus{}declspec(dllexport)}
\PYG{c+cp}{\PYGZsh{}else}
\PYG{c+cp}{\PYGZsh{}define LEAP\PYGZus{}EXPORT \PYGZus{}\PYGZus{}declspec(dllimport)}
\PYG{c+cp}{\PYGZsh{}endif}
\PYG{c+cp}{\PYGZsh{}define LEAP\PYGZus{}EXPORT\PYGZus{}CLASS}
\PYG{c+cp}{\PYGZsh{}define LEAP\PYGZus{}EXPORT\PYGZus{}PLUGIN \PYGZus{}\PYGZus{}declspec(dllexport)}
\PYG{c+cp}{\PYGZsh{}elif !defined(SWIG)}
\PYG{c+cp}{\PYGZsh{}define LEAP\PYGZus{}EXPORT \PYGZus{}\PYGZus{}attribute\PYGZus{}\PYGZus{}((visibility(\PYGZdq{}default\PYGZdq{})))}
\PYG{c+cp}{\PYGZsh{}define LEAP\PYGZus{}EXPORT\PYGZus{}CLASS \PYGZus{}\PYGZus{}attribute\PYGZus{}\PYGZus{}((visibility(\PYGZdq{}default\PYGZdq{})))}
\PYG{c+cp}{\PYGZsh{}define LEAP\PYGZus{}EXPORT\PYGZus{}PLUGIN \PYGZus{}\PYGZus{}attribute\PYGZus{}\PYGZus{}((visibility(\PYGZdq{}default\PYGZdq{})))}
\PYG{c+cp}{\PYGZsh{}else}
\PYG{c+cp}{\PYGZsh{}define LEAP\PYGZus{}EXPORT}
\PYG{c+cp}{\PYGZsh{}define LEAP\PYGZus{}EXPORT\PYGZus{}CLASS}
\PYG{c+cp}{\PYGZsh{}define LEAP\PYGZus{}EXPORT\PYGZus{}PLUGIN}
\PYG{c+cp}{\PYGZsh{}endif}

\PYG{k}{namespace} \PYG{n}{Leap} \PYG{p}{\PYGZob{}}

  \PYG{c+c1}{// Interface for internal use only}
  \PYG{k}{class} \PYG{n+nc}{LEAP\PYGZus{}EXPORT\PYGZus{}CLASS} \PYG{n}{Interface} \PYG{p}{\PYGZob{}}
  \PYG{k}{public}\PYG{o}{:}
    \PYG{k}{struct} \PYG{n}{Implementation} \PYG{p}{\PYGZob{}}
      \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{virtual} \PYG{o}{\PYGZti{}}\PYG{n}{Implementation}\PYG{p}{()} \PYG{p}{\PYGZob{}\PYGZcb{}}
    \PYG{p}{\PYGZcb{};}
  \PYG{k}{protected}\PYG{o}{:}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Interface}\PYG{p}{(}\PYG{k+kt}{void}\PYG{o}{*} \PYG{n}{owner}\PYG{p}{);}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n+nf}{Interface}\PYG{p}{(}\PYG{n}{Implementation}\PYG{o}{*} \PYG{n}{reference}\PYG{p}{,} \PYG{k+kt}{void}\PYG{o}{*} \PYG{n}{owner}\PYG{p}{);}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n+nf}{Interface}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Interface}\PYG{o}{\PYGZam{}} \PYG{n}{rhs}\PYG{p}{);}
    \PYG{n}{Interface}\PYG{p}{(}\PYG{k}{class} \PYG{n+nc}{SharedObject}\PYG{o}{*} \PYG{n}{object}\PYG{p}{);}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Interface}\PYG{o}{\PYGZam{}} \PYG{k}{operator}\PYG{o}{=}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Interface}\PYG{o}{\PYGZam{}} \PYG{n}{rhs}\PYG{p}{);}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{virtual} \PYG{o}{\PYGZti{}}\PYG{n}{Interface}\PYG{p}{();}
    \PYG{k}{template}\PYG{o}{\PYGZlt{}}\PYG{k}{typename} \PYG{n}{T}\PYG{o}{\PYGZgt{}} \PYG{n}{T}\PYG{o}{*} \PYG{n}{get}\PYG{p}{()} \PYG{k}{const} \PYG{p}{\PYGZob{}} \PYG{k}{return} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{*\PYGZgt{}}\PYG{p}{(}\PYG{n}{reference}\PYG{p}{());} \PYG{p}{\PYGZcb{}}
    \PYG{k}{class} \PYG{n+nc}{SharedObject}\PYG{o}{*} \PYG{n}{m\PYGZus{}object}\PYG{p}{;}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{static} \PYG{k+kt}{void} \PYG{n+nf}{deleteCString}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{cstr}\PYG{p}{);}
  \PYG{k}{private}\PYG{o}{:}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Implementation}\PYG{o}{*} \PYG{n}{reference}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}
  \PYG{p}{\PYGZcb{};}

  \PYG{c+c1}{// Forward declarations for internal use only}
  \PYG{k}{class} \PYG{n+nc}{PointableImplementation}\PYG{p}{;}
  \PYG{k}{class} \PYG{n+nc}{BoneImplementation}\PYG{p}{;}
  \PYG{k}{class} \PYG{n+nc}{FingerImplementation}\PYG{p}{;}
  \PYG{k}{class} \PYG{n+nc}{ToolImplementation}\PYG{p}{;}
  \PYG{k}{class} \PYG{n+nc}{HandImplementation}\PYG{p}{;}
  \PYG{k}{class} \PYG{n+nc}{GestureImplementation}\PYG{p}{;}
  \PYG{k}{class} \PYG{n+nc}{ScreenImplementation}\PYG{p}{;}
  \PYG{k}{class} \PYG{n+nc}{DeviceImplementation}\PYG{p}{;}
  \PYG{k}{class} \PYG{n+nc}{ImageImplementation}\PYG{p}{;}
  \PYG{k}{class} \PYG{n+nc}{InteractionBoxImplementation}\PYG{p}{;}
  \PYG{k}{class} \PYG{n+nc}{BugReportImplementation}\PYG{p}{;}
  \PYG{k}{class} \PYG{n+nc}{FrameImplementation}\PYG{p}{;}
  \PYG{k}{class} \PYG{n+nc}{ControllerImplementation}\PYG{p}{;}
  \PYG{k}{class} \PYG{n+nc}{MaskImplementation}\PYG{p}{;}
  \PYG{k}{class} \PYG{n+nc}{TrackedQuadImplementation}\PYG{p}{;}
  \PYG{k}{template}\PYG{o}{\PYGZlt{}}\PYG{k}{typename} \PYG{n}{T}\PYG{o}{\PYGZgt{}} \PYG{k}{class} \PYG{n+nc}{ListBaseImplementation}\PYG{p}{;}

  \PYG{c+c1}{// Forward declarations}
  \PYG{k}{class} \PYG{n+nc}{PointableList}\PYG{p}{;}
  \PYG{k}{class} \PYG{n+nc}{FingerList}\PYG{p}{;}
  \PYG{k}{class} \PYG{n+nc}{ToolList}\PYG{p}{;}
  \PYG{k}{class} \PYG{n+nc}{HandList}\PYG{p}{;}
  \PYG{k}{class} \PYG{n+nc}{GestureList}\PYG{p}{;}
  \PYG{k}{class} \PYG{n+nc}{ImageList}\PYG{p}{;}
  \PYG{k}{class} \PYG{n+nc}{MaskList}\PYG{p}{;}
  \PYG{k}{class} \PYG{n+nc}{Hand}\PYG{p}{;}
  \PYG{k}{class} \PYG{n+nc}{Gesture}\PYG{p}{;}
  \PYG{k}{class} \PYG{n+nc}{Screen}\PYG{p}{;}
  \PYG{k}{class} \PYG{n+nc}{InteractionBox}\PYG{p}{;}
  \PYG{k}{class} \PYG{n+nc}{Frame}\PYG{p}{;}
  \PYG{k}{class} \PYG{n+nc}{Listener}\PYG{p}{;}

  \PYG{c+cm}{/**}
\PYG{c+cm}{   * The Pointable class reports the physical characteristics of a detected finger or tool.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * Both fingers and tools are classified as Pointable objects. Use the Pointable::isFinger()}
\PYG{c+cm}{   * function to determine whether a Pointable object represents a finger. Use the}
\PYG{c+cm}{   * Pointable::isTool() function to determine whether a Pointable object represents a tool.}
\PYG{c+cm}{   * The Leap Motion software classifies a detected entity as a tool when it is thinner, straighter, and longer}
\PYG{c+cm}{   * than a typical finger.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * \PYGZbs{}include Pointable\PYGZus{}Get\PYGZus{}Basic.txt}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * To provide touch emulation, the Leap Motion software associates a floating touch}
\PYG{c+cm}{   * plane that adapts to the user\PYGZsq{}s finger movement and hand posture. The Leap Motion}
\PYG{c+cm}{   * interprets purposeful movements toward this plane as potential touch points.}
\PYG{c+cm}{   * The Pointable class reports}
\PYG{c+cm}{   * touch state with the touchZone and touchDistance values.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * Note that Pointable objects can be invalid, which means that they do not contain}
\PYG{c+cm}{   * valid tracking data and do not correspond to a physical entity. Invalid Pointable}
\PYG{c+cm}{   * objects can be the result of asking for a Pointable object using an ID from an}
\PYG{c+cm}{   * earlier frame when no Pointable objects with that ID exist in the current frame.}
\PYG{c+cm}{   * A Pointable object created from the Pointable constructor is also invalid.}
\PYG{c+cm}{   * Test for validity with the Pointable::isValid() function.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * @since 1.0}
\PYG{c+cm}{   */}
  \PYG{k}{class} \PYG{n+nc}{Pointable} \PYG{o}{:} \PYG{k}{public} \PYG{n}{Interface} \PYG{p}{\PYGZob{}}
  \PYG{k}{public}\PYG{o}{:}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Defines the values for reporting the state of a Pointable object in relation to}
\PYG{c+cm}{     * an adaptive touch plane.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{k}{enum} \PYG{n}{Zone} \PYG{p}{\PYGZob{}}
      \PYG{c+cm}{/**}
\PYG{c+cm}{       * The Pointable object is too far from the plane to be}
\PYG{c+cm}{       * considered hovering or touching.}
\PYG{c+cm}{       * @since 1.0}
\PYG{c+cm}{       */}
      \PYG{n}{ZONE\PYGZus{}NONE}       \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,}
      \PYG{c+cm}{/**}
\PYG{c+cm}{       * The Pointable object is close to, but not touching}
\PYG{c+cm}{       * the plane.}
\PYG{c+cm}{       * @since 1.0}
\PYG{c+cm}{       */}
      \PYG{n}{ZONE\PYGZus{}HOVERING}   \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,}
      \PYG{c+cm}{/**}
\PYG{c+cm}{       * The Pointable has penetrated the plane.}
\PYG{c+cm}{       * @since 1.0}
\PYG{c+cm}{       */}
      \PYG{n}{ZONE\PYGZus{}TOUCHING}   \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{,}
\PYG{c+cp}{\PYGZsh{}ifdef SWIGCSHARP}
      \PYG{c+c1}{// deprecated}
      \PYG{n}{ZONENONE}        \PYG{o}{=} \PYG{n}{ZONE\PYGZus{}NONE}\PYG{p}{,}
      \PYG{n}{ZONEHOVERING}    \PYG{o}{=} \PYG{n}{ZONE\PYGZus{}HOVERING}\PYG{p}{,}
      \PYG{n}{ZONETOUCHING}    \PYG{o}{=} \PYG{n}{ZONE\PYGZus{}TOUCHING}\PYG{p}{,}
\PYG{c+cp}{\PYGZsh{}endif}
    \PYG{p}{\PYGZcb{};}

    \PYG{c+c1}{// For internal use only.}
    \PYG{n}{Pointable}\PYG{p}{(}\PYG{n}{PointableImplementation}\PYG{o}{*}\PYG{p}{);}
    \PYG{c+c1}{// For internal use only.}
    \PYG{n}{Pointable}\PYG{p}{(}\PYG{n}{FingerImplementation}\PYG{o}{*}\PYG{p}{);}
    \PYG{c+c1}{// For internal use only.}
    \PYG{n}{Pointable}\PYG{p}{(}\PYG{n}{ToolImplementation}\PYG{o}{*}\PYG{p}{);}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Constructs a Pointable object.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * An uninitialized pointable is considered invalid.}
\PYG{c+cm}{     * Get valid Pointable objects from a Frame or a Hand object.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Pointable\PYGZus{}Pointable.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n+nf}{Pointable}\PYG{p}{();}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * A unique ID assigned to this Pointable object, whose value remains the}
\PYG{c+cm}{     * same across consecutive frames while the tracked finger or tool remains}
\PYG{c+cm}{     * visible. If tracking is lost (for example, when a finger is occluded by}
\PYG{c+cm}{     * another finger or when it is withdrawn from the Leap Motion Controller field of view), the}
\PYG{c+cm}{     * Leap Motion software may assign a new ID when it detects the entity in a future frame.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Pointable\PYGZus{}id.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Use the ID value with the Frame::pointable() function to find this}
\PYG{c+cm}{     * Pointable object in future frames.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * IDs should be from 1 to 100 (inclusive). If more than 100 objects are tracked}
\PYG{c+cm}{     * an IDs of \PYGZhy{}1 will be used until an ID in the defined range is available.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The ID assigned to this Pointable object.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{int32\PYGZus{}t} \PYG{n+nf}{id}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The Frame associated with this Pointable object.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Pointable\PYGZus{}frame.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The associated Frame object, if available; otherwise,}
\PYG{c+cm}{     * an invalid Frame object is returned.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Frame} \PYG{n+nf}{frame}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The Hand associated with a finger.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Pointable\PYGZus{}hand.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Not that in version 2+, tools are not associated with hands. For}
\PYG{c+cm}{     * tools, this function always returns an invalid Hand object.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The associated Hand object, if available; otherwise,}
\PYG{c+cm}{     * an invalid Hand object is returned.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Hand} \PYG{n+nf}{hand}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The tip position in millimeters from the Leap Motion origin.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Pointable\PYGZus{}tipPosition.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The Vector containing the coordinates of the tip position.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Vector} \PYG{n+nf}{tipPosition}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The rate of change of the tip position in millimeters/second.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Pointable\PYGZus{}tipVelocity.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The Vector containing the coordinates of the tip velocity.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Vector} \PYG{n+nf}{tipVelocity}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The direction in which this finger or tool is pointing.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Pointable\PYGZus{}direction.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * The direction is expressed as a unit vector pointing in the same}
\PYG{c+cm}{     * direction as the tip.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}image html images/Leap\PYGZus{}Finger\PYGZus{}Model.png}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The Vector pointing in the same direction as the tip of this}
\PYG{c+cm}{     * Pointable object.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Vector} \PYG{n+nf}{direction}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The estimated width of the finger or tool in millimeters.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Pointable\PYGZus{}width.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The estimated width of this Pointable object.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{float} \PYG{n+nf}{width}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The estimated length of the finger or tool in millimeters.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Pointable\PYGZus{}length.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The estimated length of this Pointable object.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{float} \PYG{n+nf}{length}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Whether or not this Pointable is classified as a finger.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Pointable\PYGZus{}Conversion.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns True, if this Pointable is classified as a finger.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{n+nf}{isFinger}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Whether or not this Pointable is classified as a tool.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Pointable\PYGZus{}Conversion.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns True, if this Pointable is classified as a tool.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{n+nf}{isTool}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Whether or not this Pointable is in an extended posture.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * A finger is considered extended if it is extended straight from the hand as if}
\PYG{c+cm}{     * pointing. A finger is not extended when it is bent down and curled towards the}
\PYG{c+cm}{     * palm.  Tools are always extended.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Finger\PYGZus{}isExtended.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns True, if the pointable is extended.}
\PYG{c+cm}{     * @since 2.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{n+nf}{isExtended}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Reports whether this is a valid Pointable object.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Pointable\PYGZus{}isValid.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns True, if this Pointable object contains valid tracking data.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{n+nf}{isValid}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The current touch zone of this Pointable object.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * The Leap Motion software computes the touch zone based on a floating touch}
\PYG{c+cm}{     * plane that adapts to the user\PYGZsq{}s finger movement and hand posture. The Leap}
\PYG{c+cm}{     * Motion software interprets purposeful movements toward this plane as potential touch}
\PYG{c+cm}{     * points. When a Pointable moves close to the adaptive touch plane, it enters the}
\PYG{c+cm}{     * \PYGZdq{}hovering\PYGZdq{} zone. When a Pointable reaches or passes through the plane, it enters}
\PYG{c+cm}{     * the \PYGZdq{}touching\PYGZdq{} zone.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * The possible states are present in the Zone enum of this class:}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * **Zone.NONE** \PYGZhy{}\PYGZhy{} The Pointable is outside the hovering zone.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * **Zone.HOVERING** \PYGZhy{}\PYGZhy{} The Pointable is close to, but not touching the touch plane.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * **Zone.TOUCHING** \PYGZhy{}\PYGZhy{} The Pointable has penetrated the touch plane.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * The touchDistance value provides a normalized indication of the distance to}
\PYG{c+cm}{     * the touch plane when the Pointable is in the hovering or touching zones.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Pointable\PYGZus{}touchZone.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The touch zone of this Pointable}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Zone} \PYG{n+nf}{touchZone}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * A value proportional to the distance between this Pointable object and the}
\PYG{c+cm}{     * adaptive touch plane.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}image html images/Leap\PYGZus{}Touch\PYGZus{}Plane.png}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * The touch distance is a value in the range [\PYGZhy{}1, 1]. The value 1.0 indicates the}
\PYG{c+cm}{     * Pointable is at the far edge of the hovering zone. The value 0 indicates the}
\PYG{c+cm}{     * Pointable is just entering the touching zone. A value of \PYGZhy{}1.0 indicates the}
\PYG{c+cm}{     * Pointable is firmly within the touching zone. Values in between are}
\PYG{c+cm}{     * proportional to the distance from the plane. Thus, the touchDistance of 0.5}
\PYG{c+cm}{     * indicates that the Pointable is halfway into the hovering zone.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Pointable\PYGZus{}touchDistance.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * You can use the touchDistance value to modulate visual feedback given to the}
\PYG{c+cm}{     * user as their fingers close in on a touch target, such as a button.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The normalized touch distance of this Pointable object.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{float} \PYG{n+nf}{touchDistance}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The stabilized tip position of this Pointable.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Smoothing and stabilization is performed in order to make}
\PYG{c+cm}{     * this value more suitable for interaction with 2D content. The stabilized}
\PYG{c+cm}{     * position lags behind the tip position by a variable amount, depending}
\PYG{c+cm}{     * primarily on the speed of movement.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Pointable\PYGZus{}stabilizedTipPosition.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns A modified tip position of this Pointable object}
\PYG{c+cm}{     * with some additional smoothing and stabilization applied.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Vector} \PYG{n+nf}{stabilizedTipPosition}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The duration of time this Pointable has been visible to the Leap Motion Controller.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Pointable\PYGZus{}timeVisible.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The duration (in seconds) that this Pointable has been tracked.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{float} \PYG{n+nf}{timeVisible}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Returns an invalid Pointable object.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * You can use the instance returned by this function in comparisons testing}
\PYG{c+cm}{     * whether a given Pointable instance is valid or invalid. (You can also use the}
\PYG{c+cm}{     * Pointable::isValid() function.)}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Pointable\PYGZus{}invalid.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The invalid Pointable instance.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{static} \PYG{k}{const} \PYG{n}{Pointable}\PYG{o}{\PYGZam{}} \PYG{n}{invalid}\PYG{p}{();}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Compare Pointable object equality.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Pointable\PYGZus{}operator\PYGZus{}equals.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Two Pointable objects are equal if and only if both Pointable objects represent the}
\PYG{c+cm}{     * exact same physical entities in the same frame and both Pointable objects are valid.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{k}{operator}\PYG{o}{==}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Pointable}\PYG{o}{\PYGZam{}}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Compare Pointable object inequality.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Pointable\PYGZus{}operator\PYGZus{}not\PYGZus{}equal.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Two Pointable objects are equal if and only if both Pointable objects represent the}
\PYG{c+cm}{     * exact same physical entities in the same frame and both Pointable objects are valid.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{k}{operator}\PYG{o}{!=}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Pointable}\PYG{o}{\PYGZam{}}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Writes a brief, human readable description of the Pointable object to an output stream.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Pointable\PYGZus{}operator\PYGZus{}stream.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{friend} \PYG{n}{std}\PYG{o}{::}\PYG{n}{ostream}\PYG{o}{\PYGZam{}} \PYG{k}{operator}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{p}{(}\PYG{n}{std}\PYG{o}{::}\PYG{n}{ostream}\PYG{o}{\PYGZam{}}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Pointable}\PYG{o}{\PYGZam{}}\PYG{p}{);}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * A string containing a brief, human readable description of the Pointable object.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns A description of the Pointable object as a string.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{std}\PYG{o}{::}\PYG{n}{string} \PYG{n}{toString}\PYG{p}{()} \PYG{k}{const} \PYG{p}{\PYGZob{}}
      \PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{cstr} \PYG{o}{=} \PYG{n}{toCString}\PYG{p}{();}
      \PYG{n}{std}\PYG{o}{::}\PYG{n}{string} \PYG{n}{str}\PYG{p}{(}\PYG{n}{cstr}\PYG{p}{);}
      \PYG{n}{deleteCString}\PYG{p}{(}\PYG{n}{cstr}\PYG{p}{);}
      \PYG{k}{return} \PYG{n}{str}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
  \PYG{k}{private}\PYG{o}{:}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{toCString}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

  \PYG{p}{\PYGZcb{};}

  \PYG{c+cm}{/**}
\PYG{c+cm}{   * The Arm class represents the forearm.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   */}
  \PYG{k}{class} \PYG{n+nc}{Arm} \PYG{o}{:} \PYG{k}{public} \PYG{n}{Interface} \PYG{p}{\PYGZob{}}
  \PYG{k}{public}\PYG{o}{:}
    \PYG{c+c1}{// For internal use only.}
    \PYG{n}{Arm}\PYG{p}{(}\PYG{n}{HandImplementation}\PYG{o}{*}\PYG{p}{);}

    \PYG{c+cm}{/**}
\PYG{c+cm}{    * Constructs an invalid Arm object.}
\PYG{c+cm}{    *}
\PYG{c+cm}{    * Get valid Arm objects from a Hand object.}
\PYG{c+cm}{    *}
\PYG{c+cm}{    * \PYGZbs{}include Arm\PYGZus{}get.txt}
\PYG{c+cm}{    *}
\PYG{c+cm}{    * @since 2.0.3}
\PYG{c+cm}{    */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n+nf}{Arm}\PYG{p}{();}

    \PYG{c+cm}{/**}
\PYG{c+cm}{    * The average width of the arm.}
\PYG{c+cm}{    *}
\PYG{c+cm}{    * \PYGZbs{}include Arm\PYGZus{}width.txt}
\PYG{c+cm}{    *}
\PYG{c+cm}{    * @since 2.0.3}
\PYG{c+cm}{    */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{float} \PYG{n+nf}{width}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{    * The normalized direction in which the arm is pointing (from elbow to wrist).}
\PYG{c+cm}{    *}
\PYG{c+cm}{    * \PYGZbs{}include Arm\PYGZus{}direction.txt}
\PYG{c+cm}{    *}
\PYG{c+cm}{    * @since 2.0.3}
\PYG{c+cm}{    */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Vector} \PYG{n+nf}{direction}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The orthonormal basis vectors for the Arm bone as a Matrix.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Basis vectors specify the orientation of a bone.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * **xBasis** Perpendicular to the longitudinal axis of the}
\PYG{c+cm}{     *   bone; exits the arm laterally through the sides of the wrist.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * **yBasis or up vector** Perpendicular to the longitudinal}
\PYG{c+cm}{     *   axis of the bone; exits the top and bottom of the arm. More positive}
\PYG{c+cm}{     *   in the upward direction.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * **zBasis** Aligned with the longitudinal axis of the arm bone.}
\PYG{c+cm}{     *   More positive toward the wrist.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Arm\PYGZus{}basis.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * The bases provided for the right arm use the right\PYGZhy{}hand rule; those for}
\PYG{c+cm}{     * the left arm use the left\PYGZhy{}hand rule. Thus, the positive direction of the}
\PYG{c+cm}{     * x\PYGZhy{}basis is to the right for the right arm and to the left for the left}
\PYG{c+cm}{     * arm. You can change from right\PYGZhy{}hand to left\PYGZhy{}hand rule by multiplying the}
\PYG{c+cm}{     * z basis vector by \PYGZhy{}1.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Note that converting the basis vectors directly into a quaternion}
\PYG{c+cm}{     * representation is not mathematically valid. If you use quaternions,}
\PYG{c+cm}{     * create them from the derived rotation matrix not directly from the bases.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The basis of the arm bone as a matrix.}
\PYG{c+cm}{     * @since 2.0.3}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Matrix} \PYG{n+nf}{basis}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{    * The position of the elbow.}
\PYG{c+cm}{    *}
\PYG{c+cm}{    * \PYGZbs{}include Arm\PYGZus{}elbowPosition.txt}
\PYG{c+cm}{    *}
\PYG{c+cm}{    * If not in view, the elbow position is estimated based on typical human}
\PYG{c+cm}{    * anatomical proportions.}
\PYG{c+cm}{    *}
\PYG{c+cm}{    * @since 2.0.3}
\PYG{c+cm}{    */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Vector} \PYG{n+nf}{elbowPosition}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{    * The position of the wrist.}
\PYG{c+cm}{    *}
\PYG{c+cm}{    * \PYGZbs{}include Arm\PYGZus{}wristPosition.txt}
\PYG{c+cm}{    *}
\PYG{c+cm}{    * Note that the wrist position is not collocated with the end of any bone in}
\PYG{c+cm}{    * the hand. There is a gap of a few centimeters since the carpal bones are}
\PYG{c+cm}{    * not included in the skeleton model.}
\PYG{c+cm}{    *}
\PYG{c+cm}{    * @since 2.0.3}
\PYG{c+cm}{    */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Vector} \PYG{n+nf}{wristPosition}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{    * The center of the forearm.}
\PYG{c+cm}{    *}
\PYG{c+cm}{    * This location represents the midpoint of the arm between the wrist position}
\PYG{c+cm}{    * and the elbow position.}
\PYG{c+cm}{    *}
\PYG{c+cm}{    * @since 2.1.0}
\PYG{c+cm}{    */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Vector} \PYG{n+nf}{center}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{    * Reports whether this is a valid Arm object.}
\PYG{c+cm}{    *}
\PYG{c+cm}{    * \PYGZbs{}include Arm\PYGZus{}isValid.txt}
\PYG{c+cm}{    *}
\PYG{c+cm}{    * @returns True, if this Arm object contains valid tracking data.}
\PYG{c+cm}{    * @since 2.0.3}
\PYG{c+cm}{    */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{n+nf}{isValid}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Returns an invalid Arm object.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Arm\PYGZus{}invalid.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The invalid Arm instance.}
\PYG{c+cm}{     * @since 2.0.3}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{static} \PYG{k}{const} \PYG{n}{Arm}\PYG{o}{\PYGZam{}} \PYG{n}{invalid}\PYG{p}{();}

    \PYG{c+cm}{/**}
\PYG{c+cm}{    * Compare Arm object equality.}
\PYG{c+cm}{    *}
\PYG{c+cm}{    * \PYGZbs{}include Arm\PYGZus{}operator\PYGZus{}equals.txt}
\PYG{c+cm}{    *}
\PYG{c+cm}{    * Two Arm objects are equal if and only if both Arm objects represent the}
\PYG{c+cm}{    * exact same physical arm in the same frame and both Arm objects are valid.}
\PYG{c+cm}{    * @since 2.0.3}
\PYG{c+cm}{    */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{k}{operator}\PYG{o}{==}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Arm}\PYG{o}{\PYGZam{}}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{    * Compare Arm object inequality.}
\PYG{c+cm}{    *}
\PYG{c+cm}{    * \PYGZbs{}include Arm\PYGZus{}operator\PYGZus{}not\PYGZus{}equals.txt}
\PYG{c+cm}{    *}
\PYG{c+cm}{    * Two Arm objects are equal if and only if both Arm objects represent the}
\PYG{c+cm}{    * exact same physical arm in the same frame and both Arm objects are valid.}
\PYG{c+cm}{    * @since 2.0.3}
\PYG{c+cm}{    */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{k}{operator}\PYG{o}{!=}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Arm}\PYG{o}{\PYGZam{}}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{    * Writes a brief, human readable description of the Arm object to an output stream.}
\PYG{c+cm}{    *}
\PYG{c+cm}{    * \PYGZbs{}include Arm\PYGZus{}stream.txt}
\PYG{c+cm}{    *}
\PYG{c+cm}{    * @since 2.0.3}
\PYG{c+cm}{    */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{friend} \PYG{n}{std}\PYG{o}{::}\PYG{n}{ostream}\PYG{o}{\PYGZam{}} \PYG{k}{operator}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{p}{(}\PYG{n}{std}\PYG{o}{::}\PYG{n}{ostream}\PYG{o}{\PYGZam{}}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Arm}\PYG{o}{\PYGZam{}}\PYG{p}{);}

    \PYG{c+cm}{/**}
\PYG{c+cm}{    * A string containing a brief, human readable description of the Arm object.}
\PYG{c+cm}{    *}
\PYG{c+cm}{    * \PYGZbs{}include Arm\PYGZus{}toString.txt}
\PYG{c+cm}{    *}
\PYG{c+cm}{    * @returns A description of the Arm object as a string.}
\PYG{c+cm}{    * @since 2.0.3}
\PYG{c+cm}{    */}
    \PYG{n}{std}\PYG{o}{::}\PYG{n}{string} \PYG{n}{toString}\PYG{p}{()} \PYG{k}{const} \PYG{p}{\PYGZob{}}
      \PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{cstr} \PYG{o}{=} \PYG{n}{toCString}\PYG{p}{();}
      \PYG{n}{std}\PYG{o}{::}\PYG{n}{string} \PYG{n}{str}\PYG{p}{(}\PYG{n}{cstr}\PYG{p}{);}
      \PYG{n}{deleteCString}\PYG{p}{(}\PYG{n}{cstr}\PYG{p}{);}
      \PYG{k}{return} \PYG{n}{str}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
  \PYG{k}{private}\PYG{o}{:}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{toCString}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

  \PYG{p}{\PYGZcb{};}

  \PYG{c+cm}{/**}
\PYG{c+cm}{   * The Bone class represents a tracked bone.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * All fingers contain 4 bones that make up the anatomy of the finger.}
\PYG{c+cm}{   * Get valid Bone objects from a Finger object.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * Bones are ordered from base to tip, indexed from 0 to 3.  Additionally, the}
\PYG{c+cm}{   * bone\PYGZsq{}s Type enum may be used to index a specific bone anatomically.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * \PYGZbs{}include Bone\PYGZus{}iteration.txt}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * The thumb does not have a base metacarpal bone and therefore contains a valid,}
\PYG{c+cm}{   * zero length bone at that location.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * Note that Bone objects can be invalid, which means that they do not contain}
\PYG{c+cm}{   * valid tracking data and do not correspond to a physical bone. Invalid Bone}
\PYG{c+cm}{   * objects can be the result of asking for a Bone object from an invalid finger,}
\PYG{c+cm}{   * indexing a bone out of range, or constructing a new bone.}
\PYG{c+cm}{   * Test for validity with the Bone::isValid() function.}
\PYG{c+cm}{   * @since 2.0}
\PYG{c+cm}{   */}
  \PYG{k}{class} \PYG{n+nc}{Bone} \PYG{o}{:} \PYG{k}{public} \PYG{n}{Interface} \PYG{p}{\PYGZob{}}
  \PYG{k}{public}\PYG{o}{:}
    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Enumerates the names of the bones.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Members of this enumeration are returned by Bone::type() to identify a}
\PYG{c+cm}{     * Bone object.}
\PYG{c+cm}{     * @since 2.0}
\PYG{c+cm}{     */}
    \PYG{k}{enum} \PYG{n}{Type} \PYG{p}{\PYGZob{}}
      \PYG{n}{TYPE\PYGZus{}METACARPAL} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,}   \PYG{c+cm}{/**\PYGZlt{} Bone connected to the wrist inside the palm */}
      \PYG{n}{TYPE\PYGZus{}PROXIMAL} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,}     \PYG{c+cm}{/**\PYGZlt{} Bone connecting to the palm */}
      \PYG{n}{TYPE\PYGZus{}INTERMEDIATE} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{c+cm}{/**\PYGZlt{} Bone between the tip and the base*/}
      \PYG{n}{TYPE\PYGZus{}DISTAL} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{,}       \PYG{c+cm}{/**\PYGZlt{} Bone at the tip of the finger */}
    \PYG{p}{\PYGZcb{};}

    \PYG{c+c1}{// For internal use only.}
    \PYG{n}{Bone}\PYG{p}{(}\PYG{n}{BoneImplementation}\PYG{o}{*}\PYG{p}{);}

     \PYG{c+cm}{/**}
\PYG{c+cm}{     * Constructs an invalid Bone object.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Bone\PYGZus{}invalid.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Get valid Bone objects from a Finger object.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @since 2.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n+nf}{Bone}\PYG{p}{();}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The base of the bone, closest to the wrist.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * In anatomical terms, this is the proximal end of the bone.}

\PYG{c+cm}{     * \PYGZbs{}include Bone\PYGZus{}prevJoint.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The Vector containing the coordinates of the previous joint position.}
\PYG{c+cm}{     * @since 2.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Vector} \PYG{n+nf}{prevJoint}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The end of the bone, closest to the finger tip.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * In anatomical terms, this is the distal end of the bone.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Bone\PYGZus{}nextJoint.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The Vector containing the coordinates of the next joint position.}
\PYG{c+cm}{     * @since 2.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Vector} \PYG{n+nf}{nextJoint}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The midpoint of the bone.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Bone\PYGZus{}center.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The midpoint in the center of the bone.}
\PYG{c+cm}{     * @since 2.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Vector} \PYG{n+nf}{center}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The normalized direction of the bone from base to tip.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Bone\PYGZus{}direction.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The normalized direction of the bone from base to tip.}
\PYG{c+cm}{     * @since 2.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Vector} \PYG{n+nf}{direction}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The estimated length of the bone in millimeters.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Bone\PYGZus{}length.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The length of the bone in millimeters.}
\PYG{c+cm}{     * @since 2.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{float} \PYG{n+nf}{length}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The average width of the flesh around the bone in millimeters.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Bone\PYGZus{}width.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The width of the flesh around the bone in millimeters.}
\PYG{c+cm}{     * @since 2.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{float} \PYG{n+nf}{width}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The name of this bone.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Bone\PYGZus{}type.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The anatomical type of this bone as a member of the Bone::Type}
\PYG{c+cm}{     * enumeration.}
\PYG{c+cm}{     * @since 2.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Type} \PYG{n+nf}{type}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The orthonormal basis vectors for this Bone as a Matrix.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Basis vectors specify the orientation of a bone.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * **xBasis** Perpendicular to the longitudinal axis of the}
\PYG{c+cm}{     *   bone; exits the sides of the finger.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * **yBasis or up vector** Perpendicular to the longitudinal}
\PYG{c+cm}{     *   axis of the bone; exits the top and bottom of the finger. More positive}
\PYG{c+cm}{     *   in the upward direction.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * **zBasis** Aligned with the longitudinal axis of the bone.}
\PYG{c+cm}{     *   More positive toward the base of the finger.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * The bases provided for the right hand use the right\PYGZhy{}hand rule; those for}
\PYG{c+cm}{     * the left hand use the left\PYGZhy{}hand rule. Thus, the positive direction of the}
\PYG{c+cm}{     * x\PYGZhy{}basis is to the right for the right hand and to the left for the left}
\PYG{c+cm}{     * hand. You can change from right\PYGZhy{}hand to left\PYGZhy{}hand rule by multiplying the}
\PYG{c+cm}{     * z basis vector by \PYGZhy{}1.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * You can use the basis vectors for such purposes as measuring complex}
\PYG{c+cm}{     * finger poses and skeletal animation.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Note that converting the basis vectors directly into a quaternion}
\PYG{c+cm}{     * representation is not mathematically valid. If you use quaternions,}
\PYG{c+cm}{     * create them from the derived rotation matrix not directly from the bases.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Bone\PYGZus{}basis.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The basis of the bone as a matrix.}
\PYG{c+cm}{     * @since 2.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Matrix} \PYG{n+nf}{basis}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Reports whether this is a valid Bone object.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Bone\PYGZus{}isValid.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns True, if this Bone object contains valid tracking data.}
\PYG{c+cm}{     * @since 2.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{n+nf}{isValid}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Returns an invalid Bone object.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * You can use the instance returned by this function in comparisons testing}
\PYG{c+cm}{     * whether a given Bone instance is valid or invalid. (You can also use the}
\PYG{c+cm}{     * Bone::isValid() function.)}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Bone\PYGZus{}invalid.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The invalid Bone instance.}
\PYG{c+cm}{     * @since 2.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{static} \PYG{k}{const} \PYG{n}{Bone}\PYG{o}{\PYGZam{}} \PYG{n}{invalid}\PYG{p}{();}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Compare Bone object equality.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Two Bone objects are equal if and only if both Bone objects represent the}
\PYG{c+cm}{     * exact same physical bone in the same frame and both Bone objects are valid.}
\PYG{c+cm}{     * @since 2.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{k}{operator}\PYG{o}{==}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Bone}\PYG{o}{\PYGZam{}}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Compare Bone object inequality.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Two Bone objects are equal if and only if both Bone objects represent the}
\PYG{c+cm}{     * exact same physical bone in the same frame and both Bone objects are valid.}
\PYG{c+cm}{     * @since 2.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{k}{operator}\PYG{o}{!=}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Bone}\PYG{o}{\PYGZam{}}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Writes a brief, human readable description of the Bone object to an output stream.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @since 2.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{friend} \PYG{n}{std}\PYG{o}{::}\PYG{n}{ostream}\PYG{o}{\PYGZam{}} \PYG{k}{operator}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{p}{(}\PYG{n}{std}\PYG{o}{::}\PYG{n}{ostream}\PYG{o}{\PYGZam{}}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Bone}\PYG{o}{\PYGZam{}}\PYG{p}{);}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * A string containing a brief, human readable description of the Bone object.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Bone\PYGZus{}toString.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns A description of the Bone object as a string.}
\PYG{c+cm}{     * @since 2.0}
\PYG{c+cm}{     */}
    \PYG{n}{std}\PYG{o}{::}\PYG{n}{string} \PYG{n}{toString}\PYG{p}{()} \PYG{k}{const} \PYG{p}{\PYGZob{}}
      \PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{cstr} \PYG{o}{=} \PYG{n}{toCString}\PYG{p}{();}
      \PYG{n}{std}\PYG{o}{::}\PYG{n}{string} \PYG{n}{str}\PYG{p}{(}\PYG{n}{cstr}\PYG{p}{);}
      \PYG{n}{deleteCString}\PYG{p}{(}\PYG{n}{cstr}\PYG{p}{);}
      \PYG{k}{return} \PYG{n}{str}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

  \PYG{k}{private}\PYG{o}{:}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{toCString}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}
  \PYG{p}{\PYGZcb{};}

  \PYG{c+cm}{/**}
\PYG{c+cm}{   * The Finger class represents a tracked finger.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * Fingers are Pointable objects that the Leap Motion software has classified as a finger.}
\PYG{c+cm}{   * Get valid Finger objects from a Frame or a Hand object.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * Fingers may be permanently associated to a hand. In this case the angular order of the finger IDs}
\PYG{c+cm}{   * will be invariant. As fingers move in and out of view it is possible for the guessed ID}
\PYG{c+cm}{   * of a finger to be incorrect. Consequently, it may be necessary for finger IDs to be}
\PYG{c+cm}{   * exchanged. All tracked properties, such as velocity, will remain continuous in the API.}
\PYG{c+cm}{   * However, quantities that are derived from the API output (such as a history of positions)}
\PYG{c+cm}{   * will be discontinuous unless they have a corresponding ID exchange.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * Note that Finger objects can be invalid, which means that they do not contain}
\PYG{c+cm}{   * valid tracking data and do not correspond to a physical finger. Invalid Finger}
\PYG{c+cm}{   * objects can be the result of asking for a Finger object using an ID from an}
\PYG{c+cm}{   * earlier frame when no Finger objects with that ID exist in the current frame.}
\PYG{c+cm}{   * A Finger object created from the Finger constructor is also invalid.}
\PYG{c+cm}{   * Test for validity with the Finger::isValid() function.}
\PYG{c+cm}{   * @since 1.0}
\PYG{c+cm}{   */}
  \PYG{k}{class} \PYG{n+nc}{Finger} \PYG{o}{:} \PYG{k}{public} \PYG{n}{Pointable} \PYG{p}{\PYGZob{}}
  \PYG{k}{public}\PYG{o}{:}
    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Deprecated as of version 2.0}
\PYG{c+cm}{     */}
    \PYG{k}{enum} \PYG{n}{Joint} \PYG{p}{\PYGZob{}}
      \PYG{n}{JOINT\PYGZus{}MCP} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,}
      \PYG{n}{JOINT\PYGZus{}PIP} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,}
      \PYG{n}{JOINT\PYGZus{}DIP} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{,}
      \PYG{n}{JOINT\PYGZus{}TIP} \PYG{o}{=} \PYG{l+m+mi}{3}
    \PYG{p}{\PYGZcb{};}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Enumerates the names of the fingers.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Members of this enumeration are returned by Finger::type() to identify a}
\PYG{c+cm}{     * Finger object.}
\PYG{c+cm}{     * @since 2.0}
\PYG{c+cm}{     */}
    \PYG{k}{enum} \PYG{n}{Type} \PYG{p}{\PYGZob{}}
      \PYG{n}{TYPE\PYGZus{}THUMB}  \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{c+cm}{/**\PYGZlt{} The thumb */}
      \PYG{n}{TYPE\PYGZus{}INDEX}  \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{c+cm}{/**\PYGZlt{} The index or fore\PYGZhy{}finger */}
      \PYG{n}{TYPE\PYGZus{}MIDDLE} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{c+cm}{/**\PYGZlt{} The middle finger */}
      \PYG{n}{TYPE\PYGZus{}RING}   \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{c+cm}{/**\PYGZlt{} The ring finger */}
      \PYG{n}{TYPE\PYGZus{}PINKY}  \PYG{o}{=} \PYG{l+m+mi}{4}  \PYG{c+cm}{/**\PYGZlt{} The pinky or little finger */}
    \PYG{p}{\PYGZcb{};}

    \PYG{c+c1}{// For internal use only.}
    \PYG{n}{Finger}\PYG{p}{(}\PYG{n}{FingerImplementation}\PYG{o}{*}\PYG{p}{);}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Constructs a Finger object.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * An uninitialized finger is considered invalid.}
\PYG{c+cm}{     * Get valid Finger objects from a Frame or a Hand object.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n+nf}{Finger}\PYG{p}{();}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * If the specified Pointable object represents a finger, creates a copy}
\PYG{c+cm}{     * of it as a Finger object; otherwise, creates an invalid Finger object.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Finger\PYGZus{}Finger.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{explicit} \PYG{n+nf}{Finger}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Pointable}\PYG{o}{\PYGZam{}}\PYG{p}{);}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Deprecated as of version 2.0}
\PYG{c+cm}{     * Use \PYGZsq{}bone\PYGZsq{} method instead.}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Vector} \PYG{n+nf}{jointPosition}\PYG{p}{(}\PYG{n}{Joint} \PYG{n}{jointIx}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The bone at a given bone index on this finger.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Bone\PYGZus{}iteration.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param boneIx An index value from the Bone::Type enumeration identifying the}
\PYG{c+cm}{     * bone of interest.}
\PYG{c+cm}{     * @returns The Bone that has the specified bone type.}
\PYG{c+cm}{     * @since 2.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Bone} \PYG{n+nf}{bone}\PYG{p}{(}\PYG{n}{Bone}\PYG{o}{::}\PYG{n}{Type} \PYG{n}{boneIx}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The name of this finger.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Finger\PYGZus{}type.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The anatomical type of this finger as a member of the Finger::Type}
\PYG{c+cm}{     * enumeration.}
\PYG{c+cm}{     * @since 2.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Type} \PYG{n+nf}{type}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Returns an invalid Finger object.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * You can use the instance returned by this function in comparisons testing}
\PYG{c+cm}{     * whether a given Finger instance is valid or invalid. (You can also use the}
\PYG{c+cm}{     * Finger::isValid() function.)}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Finger\PYGZus{}invalid.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The invalid Finger instance.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{static} \PYG{k}{const} \PYG{n}{Finger}\PYG{o}{\PYGZam{}} \PYG{n}{invalid}\PYG{p}{();}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * A string containing a brief, human readable description of the Finger object.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Finger\PYGZus{}toString.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns A description of the Finger object as a string.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{std}\PYG{o}{::}\PYG{n}{string} \PYG{n}{toString}\PYG{p}{()} \PYG{k}{const} \PYG{p}{\PYGZob{}}
      \PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{cstr} \PYG{o}{=} \PYG{n}{toCString}\PYG{p}{();}
      \PYG{n}{std}\PYG{o}{::}\PYG{n}{string} \PYG{n}{str}\PYG{p}{(}\PYG{n}{cstr}\PYG{p}{);}
      \PYG{n}{deleteCString}\PYG{p}{(}\PYG{n}{cstr}\PYG{p}{);}
      \PYG{k}{return} \PYG{n}{str}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

  \PYG{k}{private}\PYG{o}{:}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{toCString}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}
  \PYG{p}{\PYGZcb{};}

  \PYG{c+cm}{/**}
\PYG{c+cm}{   * The Tool class represents a tracked tool.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * Tools are Pointable objects that the Leap Motion software has classified as a tool.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * Get valid Tool objects from a Frame object.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * \PYGZbs{}image html images/Leap\PYGZus{}Tool.png}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * Note that Tool objects can be invalid, which means that they do not contain}
\PYG{c+cm}{   * valid tracking data and do not correspond to a physical tool. Invalid Tool}
\PYG{c+cm}{   * objects can be the result of asking for a Tool object using an ID from an}
\PYG{c+cm}{   * earlier frame when no Tool objects with that ID exist in the current frame.}
\PYG{c+cm}{   * A Tool object created from the Tool constructor is also invalid.}
\PYG{c+cm}{   * Test for validity with the Tool::isValid() function.}
\PYG{c+cm}{   * @since 1.0}
\PYG{c+cm}{   */}
  \PYG{k}{class} \PYG{n+nc}{Tool} \PYG{o}{:} \PYG{k}{public} \PYG{n}{Pointable} \PYG{p}{\PYGZob{}}
  \PYG{k}{public}\PYG{o}{:}
    \PYG{c+c1}{// For internal use only.}
    \PYG{n}{Tool}\PYG{p}{(}\PYG{n}{ToolImplementation}\PYG{o}{*}\PYG{p}{);}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Constructs a Tool object.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * An uninitialized tool is considered invalid.}
\PYG{c+cm}{     * Get valid Tool objects from a Frame object.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Tool\PYGZus{}Tool.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n+nf}{Tool}\PYG{p}{();}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * If the specified Pointable object represents a tool, creates a copy}
\PYG{c+cm}{     * of it as a Tool object; otherwise, creates an invalid Tool object.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Tool\PYGZus{}Tool\PYGZus{}copy.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{explicit} \PYG{n+nf}{Tool}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Pointable}\PYG{o}{\PYGZam{}}\PYG{p}{);}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Returns an invalid Tool object.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * You can use the instance returned by this function in comparisons testing}
\PYG{c+cm}{     * whether a given Tool instance is valid or invalid. (You can also use the}
\PYG{c+cm}{     * Tool::isValid() function.)}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Tool\PYGZus{}invalid.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The invalid Tool instance.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{static} \PYG{k}{const} \PYG{n}{Tool}\PYG{o}{\PYGZam{}} \PYG{n}{invalid}\PYG{p}{();}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * A string containing a brief, human readable description of the Tool object.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns A description of the Tool object as a string.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{std}\PYG{o}{::}\PYG{n}{string} \PYG{n}{toString}\PYG{p}{()} \PYG{k}{const} \PYG{p}{\PYGZob{}}
      \PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{cstr} \PYG{o}{=} \PYG{n}{toCString}\PYG{p}{();}
      \PYG{n}{std}\PYG{o}{::}\PYG{n}{string} \PYG{n}{str}\PYG{p}{(}\PYG{n}{cstr}\PYG{p}{);}
      \PYG{n}{deleteCString}\PYG{p}{(}\PYG{n}{cstr}\PYG{p}{);}
      \PYG{k}{return} \PYG{n}{str}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

  \PYG{k}{private}\PYG{o}{:}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{toCString}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}
  \PYG{p}{\PYGZcb{};}

  \PYG{c+cm}{/**}
\PYG{c+cm}{   * The Hand class reports the physical characteristics of a detected hand.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * Hand tracking data includes a palm position and velocity; vectors for}
\PYG{c+cm}{   * the palm normal and direction to the fingers; properties of a sphere fit}
\PYG{c+cm}{   * to the hand; and lists of the attached fingers.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * Get Hand objects from a Frame object:}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * \PYGZbs{}include Hand\PYGZus{}Get\PYGZus{}First.txt}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * Note that Hand objects can be invalid, which means that they do not contain}
\PYG{c+cm}{   * valid tracking data and do not correspond to a physical entity. Invalid Hand}
\PYG{c+cm}{   * objects can be the result of asking for a Hand object using an ID from an}
\PYG{c+cm}{   * earlier frame when no Hand objects with that ID exist in the current frame.}
\PYG{c+cm}{   * A Hand object created from the Hand constructor is also invalid.}
\PYG{c+cm}{   * Test for validity with the Hand::isValid() function.}
\PYG{c+cm}{   * @since 1.0}
\PYG{c+cm}{   */}
  \PYG{k}{class} \PYG{n+nc}{Hand} \PYG{o}{:} \PYG{k}{public} \PYG{n}{Interface} \PYG{p}{\PYGZob{}}
  \PYG{k}{public}\PYG{o}{:}
    \PYG{c+c1}{// For internal use only.}
    \PYG{n}{Hand}\PYG{p}{(}\PYG{n}{HandImplementation}\PYG{o}{*}\PYG{p}{);}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Constructs a Hand object.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * An uninitialized hand is considered invalid.}
\PYG{c+cm}{     * Get valid Hand objects from a Frame object.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Hand\PYGZus{}Hand.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n+nf}{Hand}\PYG{p}{();}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * A unique ID assigned to this Hand object, whose value remains the same}
\PYG{c+cm}{     * across consecutive frames while the tracked hand remains visible. If}
\PYG{c+cm}{     * tracking is lost (for example, when a hand is occluded by another hand}
\PYG{c+cm}{     * or when it is withdrawn from or reaches the edge of the Leap Motion Controller field of view),}
\PYG{c+cm}{     * the Leap Motion software may assign a new ID when it detects the hand in a future frame.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Use the ID value with the Frame::hand() function to find this Hand object}
\PYG{c+cm}{     * in future frames:}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Hand\PYGZus{}Get\PYGZus{}ID.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The ID of this hand.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{int32\PYGZus{}t} \PYG{n+nf}{id}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The Frame associated with this Hand.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Hand\PYGZus{}frame.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The associated Frame object, if available; otherwise,}
\PYG{c+cm}{     * an invalid Frame object is returned.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Frame} \PYG{n+nf}{frame}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The list of Pointable objects detected in this frame}
\PYG{c+cm}{     * that are associated with this hand, given in arbitrary order. The list}
\PYG{c+cm}{     * will always contain 5 fingers.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Use PointableList::extended() to remove non\PYGZhy{}extended fingers from the list.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Hand\PYGZus{}Get\PYGZus{}Fingers.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The PointableList containing all Pointable objects associated with this hand.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{PointableList} \PYG{n+nf}{pointables}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The Pointable object with the specified ID associated with this hand.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Use the Hand::pointable() function to retrieve a Pointable object}
\PYG{c+cm}{     * associated with this hand using an ID value obtained from a previous frame.}
\PYG{c+cm}{     * This function always returns a Pointable object, but if no finger}
\PYG{c+cm}{     * with the specified ID is present, an invalid Pointable object is returned.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Hand\PYGZus{}Get\PYGZus{}Pointable\PYGZus{}ByID.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Note that the ID values assigned to fingers are based on the hand ID.}
\PYG{c+cm}{     * Hand IDs persist across frames, but only until}
\PYG{c+cm}{     * tracking of that hand is lost. If tracking of the hand is lost and subsequently}
\PYG{c+cm}{     * regained, the new Hand object and its child Finger objects will have a}
\PYG{c+cm}{     * different ID than in an earlier frame.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param id The ID value of a Pointable object from a previous frame.}
\PYG{c+cm}{     * @returns The Pointable object with the matching ID if one exists for this}
\PYG{c+cm}{     * hand in this frame; otherwise, an invalid Pointable object is returned.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Pointable} \PYG{n+nf}{pointable}\PYG{p}{(}\PYG{k+kt}{int32\PYGZus{}t} \PYG{n}{id}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The list of Finger objects detected in this frame that are attached to}
\PYG{c+cm}{     * this hand, given in order from thumb to pinky.  The list cannot be empty.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Use PointableList::extended() to remove non\PYGZhy{}extended fingers from the list.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Hand\PYGZus{}Get\PYGZus{}Fingers.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The FingerList containing all Finger objects attached to this hand.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{FingerList} \PYG{n+nf}{fingers}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The Finger object with the specified ID attached to this hand.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Use the Hand::finger() function to retrieve a Finger object attached to}
\PYG{c+cm}{     * this hand using an ID value obtained from a previous frame.}
\PYG{c+cm}{     * This function always returns a Finger object, but if no finger}
\PYG{c+cm}{     * with the specified ID is present, an invalid Finger object is returned.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Hand\PYGZus{}finger.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Note that ID values persist across frames, but only until tracking of a}
\PYG{c+cm}{     * particular object is lost. If tracking of a finger is lost and subsequently}
\PYG{c+cm}{     * regained, the new Finger object representing that finger may have a}
\PYG{c+cm}{     * different ID than that representing the finger in an earlier frame.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param id The ID value of a Finger object from a previous frame.}
\PYG{c+cm}{     * @returns The Finger object with the matching ID if one exists for this}
\PYG{c+cm}{     * hand in this frame; otherwise, an invalid Finger object is returned.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Finger} \PYG{n+nf}{finger}\PYG{p}{(}\PYG{k+kt}{int32\PYGZus{}t} \PYG{n}{id}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/*}
\PYG{c+cm}{     * The list of Tool objects detected in this frame that are held by this}
\PYG{c+cm}{     * hand, given in arbitrary order.}
\PYG{c+cm}{     * The list can be empty if no tools held by this hand are detected.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Hand\PYGZus{}tools.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The ToolList containing all Tool objects held by this hand.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
     \PYG{c+cm}{/**}
\PYG{c+cm}{     * Tools are not associated with hands in version 2+. This list}
\PYG{c+cm}{     * is always empty.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @deprecated 2.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{ToolList} \PYG{n+nf}{tools}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/*}
\PYG{c+cm}{     * The Tool object with the specified ID held by this hand.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Use the Hand::tool() function to retrieve a Tool object held by}
\PYG{c+cm}{     * this hand using an ID value obtained from a previous frame.}
\PYG{c+cm}{     * This function always returns a Tool object, but if no tool}
\PYG{c+cm}{     * with the specified ID is present, an invalid Tool object is returned.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Hand\PYGZus{}tool.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Note that ID values persist across frames, but only until tracking of a}
\PYG{c+cm}{     * particular object is lost. If tracking of a tool is lost and subsequently}
\PYG{c+cm}{     * regained, the new Tool object representing that tool may have a}
\PYG{c+cm}{     * different ID than that representing the tool in an earlier frame.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param id The ID value of a Tool object from a previous frame.}
\PYG{c+cm}{     * @returns The Tool object with the matching ID if one exists for this}
\PYG{c+cm}{     * hand in this frame; otherwise, an invalid Tool object is returned.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
     \PYG{c+cm}{/**}
\PYG{c+cm}{     * Tools are not associated with hands in version 2+. This function}
\PYG{c+cm}{     * always returns an invalid Tool object.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @deprecated 2.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Tool} \PYG{n+nf}{tool}\PYG{p}{(}\PYG{k+kt}{int32\PYGZus{}t} \PYG{n}{id}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The center position of the palm in millimeters from the Leap Motion Controller origin.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Hand\PYGZus{}palmPosition.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The Vector representing the coordinates of the palm position.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Vector} \PYG{n+nf}{palmPosition}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The stabilized palm position of this Hand.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Smoothing and stabilization is performed in order to make}
\PYG{c+cm}{     * this value more suitable for interaction with 2D content. The stabilized}
\PYG{c+cm}{     * position lags behind the palm position by a variable amount, depending}
\PYG{c+cm}{     * primarily on the speed of movement.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Hand\PYGZus{}stabilizedPalmPosition.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns A modified palm position of this Hand object}
\PYG{c+cm}{     * with some additional smoothing and stabilization applied.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Vector} \PYG{n+nf}{stabilizedPalmPosition}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The rate of change of the palm position in millimeters/second.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Hand\PYGZus{}palmVelocity.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The Vector representing the coordinates of the palm velocity.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Vector} \PYG{n+nf}{palmVelocity}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The normal vector to the palm. If your hand is flat, this vector will}
\PYG{c+cm}{     * point downward, or \PYGZdq{}out\PYGZdq{} of the front surface of your palm.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}image html images/Leap\PYGZus{}Palm\PYGZus{}Vectors.png}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * The direction is expressed as a unit vector pointing in the same}
\PYG{c+cm}{     * direction as the palm normal (that is, a vector orthogonal to the palm).}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * You can use the palm normal vector to compute the roll angle of the palm with}
\PYG{c+cm}{     * respect to the horizontal plane:}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Hand\PYGZus{}Get\PYGZus{}Angles.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The Vector normal to the plane formed by the palm.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Vector} \PYG{n+nf}{palmNormal}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The estimated width of the palm when the hand is in a flat position.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Hand\PYGZus{}palmWidth.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The width of the palm in millimeters}
\PYG{c+cm}{     * @since 2.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{float} \PYG{n+nf}{palmWidth}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The direction from the palm position toward the fingers.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * The direction is expressed as a unit vector pointing in the same}
\PYG{c+cm}{     * direction as the directed line from the palm position to the fingers.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * You can use the palm direction vector to compute the pitch and yaw angles of the palm with}
\PYG{c+cm}{     * respect to the horizontal plane:}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Hand\PYGZus{}Get\PYGZus{}Angles.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The Vector pointing from the palm position toward the fingers.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Vector} \PYG{n+nf}{direction}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The orientation of the hand as a basis matrix.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * The basis is defined as follows:}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * **xAxis** Positive in the direction of the pinky}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * **yAxis** Positive above the hand}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * **zAxis** Positive in the direction of the wrist}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Note: Since the left hand is a mirror of the right hand, the}
\PYG{c+cm}{     * basis matrix will be left\PYGZhy{}handed for left hands.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Hand\PYGZus{}basis.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The basis of the hand as a matrix.}
\PYG{c+cm}{     * @since 2.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Matrix} \PYG{n+nf}{basis}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The arm to which this hand is attached.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * If the arm is not completely in view, Arm attributes are estimated based on}
\PYG{c+cm}{     * the attributes of entities that are in view combined with typical human anatomy.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Arm\PYGZus{}get.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The Arm object for this hand.}
\PYG{c+cm}{     * @since 2.0.3}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Arm} \PYG{n+nf}{arm}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The position of the wrist of this hand.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns A vector containing the coordinates of the wrist position in millimeters.}
\PYG{c+cm}{     * @since 2.0.3}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Vector} \PYG{n+nf}{wristPosition}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The center of a sphere fit to the curvature of this hand.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Hand\PYGZus{}sphereCenter.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * This sphere is placed roughly as if the hand were holding a ball.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}image html images/Leap\PYGZus{}Hand\PYGZus{}Ball.png}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The Vector representing the center position of the sphere.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Vector} \PYG{n+nf}{sphereCenter}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The radius of a sphere fit to the curvature of this hand.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * This sphere is placed roughly as if the hand were holding a ball. Thus the}
\PYG{c+cm}{     * size of the sphere decreases as the fingers are curled into a fist.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Hand\PYGZus{}sphereRadius.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The radius of the sphere in millimeters.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{float} \PYG{n+nf}{sphereRadius}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The holding strength of a pinch hand pose.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * The strength is zero for an open hand, and blends to 1.0 when a pinching}
\PYG{c+cm}{     * hand pose is recognized. Pinching can be done between the thumb}
\PYG{c+cm}{     * and any other finger of the same hand.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Hand\PYGZus{}pinchStrength.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns A float value in the [0..1] range representing the holding strength}
\PYG{c+cm}{     * of the pinch pose.}
\PYG{c+cm}{     * @since 2.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{float} \PYG{n+nf}{pinchStrength}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The strength of a grab hand pose.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * The strength is zero for an open hand, and blends to 1.0 when a grabbing hand}
\PYG{c+cm}{     * pose is recognized.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Hand\PYGZus{}grabStrength.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns A float value in the [0..1] range representing the holding strength}
\PYG{c+cm}{     * of the pose.}
\PYG{c+cm}{     * @since 2.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{float} \PYG{n+nf}{grabStrength}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The change of position of this hand between the current frame and}
\PYG{c+cm}{     * the specified frame.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * The returned translation vector provides the magnitude and direction of}
\PYG{c+cm}{     * the movement in millimeters.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Hand\PYGZus{}translation.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * If a corresponding Hand object is not found in sinceFrame, or if either}
\PYG{c+cm}{     * this frame or sinceFrame are invalid Frame objects, then this method}
\PYG{c+cm}{     * returns a zero vector.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param sinceFrame The starting frame for computing the translation.}
\PYG{c+cm}{     * @returns A Vector representing the heuristically determined change in}
\PYG{c+cm}{     * hand position between the current frame and that specified in the}
\PYG{c+cm}{     * sinceFrame parameter.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Vector} \PYG{n+nf}{translation}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Frame}\PYG{o}{\PYGZam{}} \PYG{n}{sinceFrame}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The estimated probability that the hand motion between the current}
\PYG{c+cm}{     * frame and the specified frame is intended to be a translating motion.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Hand\PYGZus{}translationProbability.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * If a corresponding Hand object is not found in sinceFrame, or if either}
\PYG{c+cm}{     * this frame or sinceFrame are invalid Frame objects, then this method}
\PYG{c+cm}{     * returns zero.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param sinceFrame The starting frame for computing the translation.}
\PYG{c+cm}{     * @returns A value between 0 and 1 representing the estimated probability}
\PYG{c+cm}{     * that the hand motion between the current frame and the specified frame}
\PYG{c+cm}{     * is intended to be a translating motion.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{float} \PYG{n+nf}{translationProbability}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Frame}\PYG{o}{\PYGZam{}} \PYG{n}{sinceFrame}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The axis of rotation derived from the change in orientation of this}
\PYG{c+cm}{     * hand, and any associated fingers, between the current frame}
\PYG{c+cm}{     * and the specified frame.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Hand\PYGZus{}rotationAxis.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * The returned direction vector is normalized.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * If a corresponding Hand object is not found in sinceFrame, or if either}
\PYG{c+cm}{     * this frame or sinceFrame are invalid Frame objects, then this method}
\PYG{c+cm}{     * returns a zero vector.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param sinceFrame The starting frame for computing the relative rotation.}
\PYG{c+cm}{     * @returns A normalized direction Vector representing the heuristically}
\PYG{c+cm}{     * determined axis of rotational change of the hand between the current}
\PYG{c+cm}{     * frame and that specified in the sinceFrame parameter.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Vector} \PYG{n+nf}{rotationAxis}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Frame}\PYG{o}{\PYGZam{}} \PYG{n}{sinceFrame}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The angle of rotation around the rotation axis derived from the change}
\PYG{c+cm}{     * in orientation of this hand, and any associated fingers,}
\PYG{c+cm}{     * between the current frame and the specified frame.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Hand\PYGZus{}rotationAngle.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * The returned angle is expressed in radians measured clockwise around the}
\PYG{c+cm}{     * rotation axis (using the right\PYGZhy{}hand rule) between the start and end frames.}
\PYG{c+cm}{     * The value is always between 0 and pi radians (0 and 180 degrees).}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * If a corresponding Hand object is not found in sinceFrame, or if either}
\PYG{c+cm}{     * this frame or sinceFrame are invalid Frame objects, then the angle of}
\PYG{c+cm}{     * rotation is zero.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param sinceFrame The starting frame for computing the relative rotation.}
\PYG{c+cm}{     * @returns A positive value representing the heuristically determined}
\PYG{c+cm}{     * rotational change of the hand between the current frame and that}
\PYG{c+cm}{     * specified in the sinceFrame parameter.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{float} \PYG{n+nf}{rotationAngle}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Frame}\PYG{o}{\PYGZam{}} \PYG{n}{sinceFrame}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The angle of rotation around the specified axis derived from the change}
\PYG{c+cm}{     * in orientation of this hand, and any associated fingers,}
\PYG{c+cm}{     * between the current frame and the specified frame.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Hand\PYGZus{}rotationAngle\PYGZus{}axis.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * The returned angle is expressed in radians measured clockwise around the}
\PYG{c+cm}{     * rotation axis (using the right\PYGZhy{}hand rule) between the start and end frames.}
\PYG{c+cm}{     * The value is always between \PYGZhy{}pi and pi radians (\PYGZhy{}180 and 180 degrees).}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * If a corresponding Hand object is not found in sinceFrame, or if either}
\PYG{c+cm}{     * this frame or sinceFrame are invalid Frame objects, then the angle of}
\PYG{c+cm}{     * rotation is zero.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param sinceFrame The starting frame for computing the relative rotation.}
\PYG{c+cm}{     * @param axis The axis to measure rotation around.}
\PYG{c+cm}{     * @returns A value representing the heuristically determined rotational}
\PYG{c+cm}{     * change of the hand between the current frame and that specified in the}
\PYG{c+cm}{     * sinceFrame parameter around the specified axis.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{float} \PYG{n+nf}{rotationAngle}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Frame}\PYG{o}{\PYGZam{}} \PYG{n}{sinceFrame}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZam{}} \PYG{n}{axis}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The transform matrix expressing the rotation derived from the change}
\PYG{c+cm}{     * in orientation of this hand, and any associated fingers,}
\PYG{c+cm}{     * between the current frame and the specified frame.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Hand\PYGZus{}rotationMatrix.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * If a corresponding Hand object is not found in sinceFrame, or if either}
\PYG{c+cm}{     * this frame or sinceFrame are invalid Frame objects, then this method}
\PYG{c+cm}{     * returns an identity matrix.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param sinceFrame The starting frame for computing the relative rotation.}
\PYG{c+cm}{     * @returns A transformation Matrix representing the heuristically determined}
\PYG{c+cm}{     * rotational change of the hand between the current frame and that specified}
\PYG{c+cm}{     * in the sinceFrame parameter.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Matrix} \PYG{n+nf}{rotationMatrix}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Frame}\PYG{o}{\PYGZam{}} \PYG{n}{sinceFrame}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The estimated probability that the hand motion between the current}
\PYG{c+cm}{     * frame and the specified frame is intended to be a rotating motion.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Hand\PYGZus{}rotationProbability.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * If a corresponding Hand object is not found in sinceFrame, or if either}
\PYG{c+cm}{     * this frame or sinceFrame are invalid Frame objects, then this method}
\PYG{c+cm}{     * returns zero.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param sinceFrame The starting frame for computing the relative rotation.}
\PYG{c+cm}{     * @returns A value between 0 and 1 representing the estimated probability}
\PYG{c+cm}{     * that the hand motion between the current frame and the specified frame}
\PYG{c+cm}{     * is intended to be a rotating motion.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{float} \PYG{n+nf}{rotationProbability}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Frame}\PYG{o}{\PYGZam{}} \PYG{n}{sinceFrame}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The scale factor derived from this hand\PYGZsq{}s motion between the current frame}
\PYG{c+cm}{     * and the specified frame.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * The scale factor is always positive. A value of 1.0 indicates no}
\PYG{c+cm}{     * scaling took place. Values between 0.0 and 1.0 indicate contraction}
\PYG{c+cm}{     * and values greater than 1.0 indicate expansion.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Hand\PYGZus{}scaleFactor.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * The Leap Motion software derives scaling from the relative inward or outward motion of}
\PYG{c+cm}{     * a hand and its associated fingers (independent of translation}
\PYG{c+cm}{     * and rotation).}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * If a corresponding Hand object is not found in sinceFrame, or if either}
\PYG{c+cm}{     * this frame or sinceFrame are invalid Frame objects, then this method}
\PYG{c+cm}{     * returns 1.0.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param sinceFrame The starting frame for computing the relative scaling.}
\PYG{c+cm}{     * @returns A positive value representing the heuristically determined}
\PYG{c+cm}{     * scaling change ratio of the hand between the current frame and that}
\PYG{c+cm}{     * specified in the sinceFrame parameter.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{float} \PYG{n+nf}{scaleFactor}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Frame}\PYG{o}{\PYGZam{}} \PYG{n}{sinceFrame}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The estimated probability that the hand motion between the current}
\PYG{c+cm}{     * frame and the specified frame is intended to be a scaling motion.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Hand\PYGZus{}scaleProbability.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * If a corresponding Hand object is not found in sinceFrame, or if either}
\PYG{c+cm}{     * this frame or sinceFrame are invalid Frame objects, then this method}
\PYG{c+cm}{     * returns zero.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param sinceFrame The starting frame for computing the relative scaling.}
\PYG{c+cm}{     * @returns A value between 0 and 1 representing the estimated probability}
\PYG{c+cm}{     * that the hand motion between the current frame and the specified frame}
\PYG{c+cm}{     * is intended to be a scaling motion.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{float} \PYG{n+nf}{scaleProbability}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Frame}\PYG{o}{\PYGZam{}} \PYG{n}{sinceFrame}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The duration of time this Hand has been visible to the Leap Motion Controller.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Hand\PYGZus{}timeVisible.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The duration (in seconds) that this Hand has been tracked.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{float} \PYG{n+nf}{timeVisible}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * How confident we are with a given hand pose.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * The confidence level ranges between 0.0 and 1.0 inclusive.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Hand\PYGZus{}confidence.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @since 2.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{float} \PYG{n+nf}{confidence}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Identifies whether this Hand is a left hand.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Hand\PYGZus{}isLeft.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns True if the hand is identified as a left hand.}
\PYG{c+cm}{     * @since 2.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{n+nf}{isLeft}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Identifies whether this Hand is a right hand.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Hand\PYGZus{}isRight.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns True if the hand is identified as a right hand.}
\PYG{c+cm}{     * @since 2.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{n+nf}{isRight}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Reports whether this is a valid Hand object.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Hand\PYGZus{}isValid.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns True, if this Hand object contains valid tracking data.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{n+nf}{isValid}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Returns an invalid Hand object.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Hand\PYGZus{}invalid.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * You can use the instance returned by this function in comparisons testing}
\PYG{c+cm}{     * whether a given Hand instance is valid or invalid. (You can also use the}
\PYG{c+cm}{     * Hand::isValid() function.)}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The invalid Hand instance.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{static} \PYG{k}{const} \PYG{n}{Hand}\PYG{o}{\PYGZam{}} \PYG{n}{invalid}\PYG{p}{();}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Compare Hand object equality.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Hand\PYGZus{}operator\PYGZus{}equals.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Two Hand objects are equal if and only if both Hand objects represent the}
\PYG{c+cm}{     * exact same physical hand in the same frame and both Hand objects are valid.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{k}{operator}\PYG{o}{==}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Hand}\PYG{o}{\PYGZam{}}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Compare Hand object inequality.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Hand\PYGZus{}operator\PYGZus{}not\PYGZus{}equals.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Two Hand objects are equal if and only if both Hand objects represent the}
\PYG{c+cm}{     * exact same physical hand in the same frame and both Hand objects are valid.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{k}{operator}\PYG{o}{!=}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Hand}\PYG{o}{\PYGZam{}}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Writes a brief, human readable description of the Hand object to an output stream.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Hand\PYGZus{}operator\PYGZus{}stream.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{friend} \PYG{n}{std}\PYG{o}{::}\PYG{n}{ostream}\PYG{o}{\PYGZam{}} \PYG{k}{operator}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{p}{(}\PYG{n}{std}\PYG{o}{::}\PYG{n}{ostream}\PYG{o}{\PYGZam{}}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Hand}\PYG{o}{\PYGZam{}}\PYG{p}{);}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * A string containing a brief, human readable description of the Hand object.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns A description of the Hand as a string.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{std}\PYG{o}{::}\PYG{n}{string} \PYG{n}{toString}\PYG{p}{()} \PYG{k}{const} \PYG{p}{\PYGZob{}}
      \PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{cstr} \PYG{o}{=} \PYG{n}{toCString}\PYG{p}{();}
      \PYG{n}{std}\PYG{o}{::}\PYG{n}{string} \PYG{n}{str}\PYG{p}{(}\PYG{n}{cstr}\PYG{p}{);}
      \PYG{n}{deleteCString}\PYG{p}{(}\PYG{n}{cstr}\PYG{p}{);}
      \PYG{k}{return} \PYG{n}{str}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

  \PYG{k}{private}\PYG{o}{:}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{toCString}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}
  \PYG{p}{\PYGZcb{};}

  \PYG{c+cm}{/**}
\PYG{c+cm}{   * The Gesture class represents a recognized movement by the user.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * The Leap Motion Controller watches the activity within its field of view for certain movement}
\PYG{c+cm}{   * patterns typical of a user gesture or command. For example, a movement from side to}
\PYG{c+cm}{   * side with the hand can indicate a swipe gesture, while a finger poking forward}
\PYG{c+cm}{   * can indicate a screen tap gesture.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * When the Leap Motion software recognizes a gesture, it assigns an ID and adds a}
\PYG{c+cm}{   * Gesture object to the frame gesture list. For continuous gestures, which}
\PYG{c+cm}{   * occur over many frames, the Leap Motion software updates the gesture by adding}
\PYG{c+cm}{   * a Gesture object having the same ID and updated properties in each}
\PYG{c+cm}{   * subsequent frame.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * **Important:** Recognition for each type of gesture must be enabled using the}
\PYG{c+cm}{   * Controller::enableGesture() function; otherwise **no gestures are recognized or}
\PYG{c+cm}{   * reported**.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * \PYGZbs{}include Gesture\PYGZus{}Feature\PYGZus{}enable.txt}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * Subclasses of Gesture define the properties for the specific movement patterns}
\PYG{c+cm}{   * recognized by the Leap Motion software.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * The Gesture subclasses include:}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * **CircleGesture** \PYGZhy{}\PYGZhy{} A circular movement by a finger.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * **SwipeGesture** \PYGZhy{}\PYGZhy{} A straight line movement by the hand with fingers extended.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * **ScreenTapGesture** \PYGZhy{}\PYGZhy{} A forward tapping movement by a finger.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * **KeyTapGesture** \PYGZhy{}\PYGZhy{} A downward tapping movement by a finger.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * Circle and swipe gestures are continuous and these objects can have a}
\PYG{c+cm}{   * state of start, update, and stop.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * The screen tap gesture is a discrete gesture. The Leap Motion software only creates a single}
\PYG{c+cm}{   * ScreenTapGesture object for each tap and it always has a stop state.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * Get valid Gesture instances from a Frame object. You can get a list of gestures}
\PYG{c+cm}{   * with the Frame::gestures() method. You can get a list of gestures since a}
\PYG{c+cm}{   * specified frame with the `Frame::gestures(const Frame\PYGZam{})` method. You can also}
\PYG{c+cm}{   * use the `Frame::gesture()` method to find a gesture in the current frame using}
\PYG{c+cm}{   * an ID value obtained in a previous frame.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * Gesture objects can be invalid. For example, when you get a gesture by ID}
\PYG{c+cm}{   * using `Frame::gesture()`, and there is no gesture with that ID in the current}
\PYG{c+cm}{   * frame, then `gesture()` returns an Invalid Gesture object (rather than a null}
\PYG{c+cm}{   * value). Always check object validity in situations where a gesture might be}
\PYG{c+cm}{   * invalid.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * The following keys can be used with the Config class to configure the gesture}
\PYG{c+cm}{   * recognizer:}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * \PYGZbs{}table}
\PYG{c+cm}{   * ====================================  ========== ============= =======}
\PYG{c+cm}{   * Key string                            Value type Default value Units}
\PYG{c+cm}{   * ====================================  ========== ============= =======}
\PYG{c+cm}{   * Gesture.Circle.MinRadius              float      5.0           mm}
\PYG{c+cm}{   * Gesture.Circle.MinArc                 float      1.5 * pi      radians}
\PYG{c+cm}{   * Gesture.Swipe.MinLength               float      150           mm}
\PYG{c+cm}{   * Gesture.Swipe.MinVelocity             float      1000          mm/s}
\PYG{c+cm}{   * Gesture.KeyTap.MinDownVelocity        float      50            mm/s}
\PYG{c+cm}{   * Gesture.KeyTap.HistorySeconds         float      0.1           s}
\PYG{c+cm}{   * Gesture.KeyTap.MinDistance            float      3.0           mm}
\PYG{c+cm}{   * Gesture.ScreenTap.MinForwardVelocity  float      50            mm/s}
\PYG{c+cm}{   * Gesture.ScreenTap.HistorySeconds      float      0.1           s}
\PYG{c+cm}{   * Gesture.ScreenTap.MinDistance         float      5.0           mm}
\PYG{c+cm}{   * ====================================  ========== ============= =======}
\PYG{c+cm}{   * \PYGZbs{}endtable}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * @since 1.0}
\PYG{c+cm}{   */}
  \PYG{k}{class} \PYG{n+nc}{Gesture} \PYG{o}{:} \PYG{k}{public} \PYG{n}{Interface} \PYG{p}{\PYGZob{}}
  \PYG{k}{public}\PYG{o}{:}
    \PYG{c+c1}{// For internal use only.}
    \PYG{n}{Gesture}\PYG{p}{(}\PYG{n}{GestureImplementation}\PYG{o}{*}\PYG{p}{);}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The supported types of gestures.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{k}{enum} \PYG{n}{Type} \PYG{p}{\PYGZob{}}
      \PYG{c+cm}{/**}
\PYG{c+cm}{       * An invalid type.}
\PYG{c+cm}{       * @since 1.0}
\PYG{c+cm}{       */}
      \PYG{n}{TYPE\PYGZus{}INVALID}    \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}
      \PYG{c+cm}{/**}
\PYG{c+cm}{       * A straight line movement by the hand with fingers extended.}
\PYG{c+cm}{       * @since 1.0}
\PYG{c+cm}{       */}
      \PYG{n}{TYPE\PYGZus{}SWIPE}      \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,}
      \PYG{c+cm}{/**}
\PYG{c+cm}{       * A circular movement by a finger.}
\PYG{c+cm}{       * @since 1.0}
\PYG{c+cm}{       */}
      \PYG{n}{TYPE\PYGZus{}CIRCLE}     \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{,}
      \PYG{c+cm}{/**}
\PYG{c+cm}{       * A forward tapping movement by a finger.}
\PYG{c+cm}{       * @since 1.0}
\PYG{c+cm}{       */}
      \PYG{n}{TYPE\PYGZus{}SCREEN\PYGZus{}TAP} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{,}
      \PYG{c+cm}{/**}
\PYG{c+cm}{       * A downward tapping movement by a finger.}
\PYG{c+cm}{       * @since 1.0}
\PYG{c+cm}{       */}
      \PYG{n}{TYPE\PYGZus{}KEY\PYGZus{}TAP}    \PYG{o}{=} \PYG{l+m+mi}{6}\PYG{p}{,}
\PYG{c+cp}{\PYGZsh{}ifdef SWIGCSHARP}
      \PYG{c+c1}{// deprecated}
      \PYG{n}{TYPEINVALID}     \PYG{o}{=} \PYG{n}{TYPE\PYGZus{}INVALID}\PYG{p}{,}
      \PYG{n}{TYPESWIPE}       \PYG{o}{=} \PYG{n}{TYPE\PYGZus{}SWIPE}\PYG{p}{,}
      \PYG{n}{TYPECIRCLE}      \PYG{o}{=} \PYG{n}{TYPE\PYGZus{}CIRCLE}\PYG{p}{,}
      \PYG{n}{TYPESCREENTAP}   \PYG{o}{=} \PYG{n}{TYPE\PYGZus{}SCREEN\PYGZus{}TAP}\PYG{p}{,}
      \PYG{n}{TYPEKEYTAP}      \PYG{o}{=} \PYG{n}{TYPE\PYGZus{}KEY\PYGZus{}TAP}\PYG{p}{,}
\PYG{c+cp}{\PYGZsh{}endif}
    \PYG{p}{\PYGZcb{};}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The possible gesture states.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{k}{enum} \PYG{n}{State} \PYG{p}{\PYGZob{}}
      \PYG{c+cm}{/**}
\PYG{c+cm}{       * An invalid state}
\PYG{c+cm}{       * @since 1.0}
\PYG{c+cm}{       */}
      \PYG{n}{STATE\PYGZus{}INVALID} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}
      \PYG{c+cm}{/**}
\PYG{c+cm}{       * The gesture is starting. Just enough has happened to recognize it.}
\PYG{c+cm}{       * @since 1.0}
\PYG{c+cm}{       */}
      \PYG{n}{STATE\PYGZus{}START}   \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,}
      \PYG{c+cm}{/**}
\PYG{c+cm}{       * The gesture is in progress. (Note: not all gestures have updates).}
\PYG{c+cm}{       * @since 1.0}
\PYG{c+cm}{       */}
      \PYG{n}{STATE\PYGZus{}UPDATE}  \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{,}
      \PYG{c+cm}{/**}
\PYG{c+cm}{       * The gesture has completed or stopped.}
\PYG{c+cm}{       * @since 1.0}
\PYG{c+cm}{       */}
      \PYG{n}{STATE\PYGZus{}STOP}    \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{,}
\PYG{c+cp}{\PYGZsh{}ifdef SWIGCSHARP}
      \PYG{c+c1}{// deprecated}
      \PYG{n}{STATEINVALID}  \PYG{o}{=} \PYG{n}{STATE\PYGZus{}INVALID}\PYG{p}{,}
      \PYG{n}{STATESTART}    \PYG{o}{=} \PYG{n}{STATE\PYGZus{}START}\PYG{p}{,}
      \PYG{n}{STATEUPDATE}   \PYG{o}{=} \PYG{n}{STATE\PYGZus{}UPDATE}\PYG{p}{,}
      \PYG{n}{STATESTOP}     \PYG{o}{=} \PYG{n}{STATE\PYGZus{}STOP}\PYG{p}{,}
\PYG{c+cp}{\PYGZsh{}endif}
    \PYG{p}{\PYGZcb{};}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Constructs a new Gesture object.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * An uninitialized Gesture object is considered invalid. Get valid instances}
\PYG{c+cm}{     * of the Gesture class, which will be one of the Gesture subclasses, from a}
\PYG{c+cm}{     * Frame object.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n+nf}{Gesture}\PYG{p}{();}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Constructs a new copy of an Gesture object.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Gesture\PYGZus{}Gesture\PYGZus{}copy.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n+nf}{Gesture}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Gesture}\PYG{o}{\PYGZam{}} \PYG{n}{rhs}\PYG{p}{);}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The gesture type.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Gesture\PYGZus{}type.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns Gesture::Type A value from the Gesture::Type enumeration.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Type} \PYG{n+nf}{type}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The gesture state.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Recognized movements occur over time and have a beginning, a middle,}
\PYG{c+cm}{     * and an end. The \PYGZsq{}state()\PYGZsq{} attribute reports where in that sequence this}
\PYG{c+cm}{     * Gesture object falls.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Gesture\PYGZus{}state.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns Gesture::State A value from the Gesture::State enumeration.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{State} \PYG{n+nf}{state}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The gesture ID.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * All Gesture objects belonging to the same recognized movement share the}
\PYG{c+cm}{     * same ID value. Use the ID value with the Frame::gesture() method to}
\PYG{c+cm}{     * find updates related to this Gesture object in subsequent frames.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Gesture\PYGZus{}id.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns int32\PYGZus{}t the ID of this Gesture.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{int32\PYGZus{}t} \PYG{n+nf}{id}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The elapsed duration of the recognized movement up to the}
\PYG{c+cm}{     * frame containing this Gesture object, in microseconds.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Gesture\PYGZus{}duration.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * The duration reported for the first Gesture in the sequence (with the}
\PYG{c+cm}{     * STATE\PYGZus{}START state) will typically be a small positive number since}
\PYG{c+cm}{     * the movement must progress far enough for the Leap Motion software to recognize it as}
\PYG{c+cm}{     * an intentional gesture.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @return int64\PYGZus{}t the elapsed duration in microseconds.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{int64\PYGZus{}t} \PYG{n+nf}{duration}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The elapsed duration in seconds.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Gesture\PYGZus{}durationSeconds.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @see duration()}
\PYG{c+cm}{     * @return float the elapsed duration in seconds.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{float} \PYG{n+nf}{durationSeconds}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The Frame containing this Gesture instance.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Gesture\PYGZus{}frame.txt}
\PYG{c+cm}{     \PYGZus{}}
\PYG{c+cm}{     * @return Frame The parent Frame object.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Frame} \PYG{n+nf}{frame}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The list of hands associated with this Gesture, if any.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Gesture\PYGZus{}hands.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * If no hands are related to this gesture, the list is empty.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @return HandList the list of related Hand objects.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{HandList} \PYG{n+nf}{hands}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The list of fingers and tools associated with this Gesture, if any.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * If no Pointable objects are related to this gesture, the list is empty.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Gesture\PYGZus{}pointables.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @return PointableList the list of related Pointable objects.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{PointableList} \PYG{n+nf}{pointables}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Reports whether this Gesture instance represents a valid Gesture.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * An invalid Gesture object does not represent a snapshot of a recognized}
\PYG{c+cm}{     * movement. Invalid Gesture objects are returned when a valid object cannot}
\PYG{c+cm}{     * be provided. For example, when you get an gesture by ID}
\PYG{c+cm}{     * using Frame::gesture(), and there is no gesture with that ID in the current}
\PYG{c+cm}{     * frame, then gesture() returns an Invalid Gesture object (rather than a null}
\PYG{c+cm}{     * value). Always check object validity in situations where an gesture might be}
\PYG{c+cm}{     * invalid.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Gesture\PYGZus{}isValid.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns bool True, if this is a valid Gesture instance; false, otherwise.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{n+nf}{isValid}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Compare Gesture object equality.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Gesture\PYGZus{}operator\PYGZus{}equals.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Two Gestures are equal if they represent the same snapshot of the same}
\PYG{c+cm}{     * recognized movement.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{k}{operator}\PYG{o}{==}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Gesture}\PYG{o}{\PYGZam{}} \PYG{n}{rhs}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Compare Gesture object inequality.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Gesture\PYGZus{}operator\PYGZus{}not\PYGZus{}equals.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Two Gestures are equal only if they represent the same snapshot of the same}
\PYG{c+cm}{     * recognized movement.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{k}{operator}\PYG{o}{!=}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Gesture}\PYG{o}{\PYGZam{}} \PYG{n}{rhs}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * A string containing a brief, human\PYGZhy{}readable description of this}
\PYG{c+cm}{     * Gesture.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Gesture\PYGZus{}toString.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{std}\PYG{o}{::}\PYG{n}{string} \PYG{n}{toString}\PYG{p}{()} \PYG{k}{const} \PYG{p}{\PYGZob{}}
      \PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{cstr} \PYG{o}{=} \PYG{n}{toCString}\PYG{p}{();}
      \PYG{n}{std}\PYG{o}{::}\PYG{n}{string} \PYG{n}{str}\PYG{p}{(}\PYG{n}{cstr}\PYG{p}{);}
      \PYG{n}{deleteCString}\PYG{p}{(}\PYG{n}{cstr}\PYG{p}{);}
      \PYG{k}{return} \PYG{n}{str}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Returns an invalid Gesture object.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * You can use the instance returned by this function in comparisons testing}
\PYG{c+cm}{     * whether a given Gesture instance is valid or invalid. (You can also use the}
\PYG{c+cm}{     * Gesture::isValid() function.)}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Gesture\PYGZus{}invalid.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The invalid Gesture instance.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{static} \PYG{k}{const} \PYG{n}{Gesture}\PYG{o}{\PYGZam{}} \PYG{n}{invalid}\PYG{p}{();}

  \PYG{k}{private}\PYG{o}{:}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{toCString}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}
  \PYG{p}{\PYGZcb{};}

  \PYG{c+cm}{/**}
\PYG{c+cm}{   * The SwipeGesture class represents a swiping motion a finger or tool.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * \PYGZbs{}image html images/Leap\PYGZus{}Gesture\PYGZus{}Swipe.png}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * SwipeGesture objects are generated for each visible finger or tool.}
\PYG{c+cm}{   * Swipe gestures are continuous; a gesture object with the same}
\PYG{c+cm}{   * ID value will appear in each frame while the gesture continues.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * **Important:** To use swipe gestures in your application, you must enable}
\PYG{c+cm}{   * recognition of the swipe gesture. You can enable recognition with:}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * \PYGZbs{}include Gesture\PYGZus{}Swipe\PYGZus{}Enable.txt}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * You can set the minimum length and velocity required for a movement}
\PYG{c+cm}{   * to be recognized as a swipe using the config attribute of a connected}
\PYG{c+cm}{   * Controller object. Use the following keys to configure swipe recognition:}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * \PYGZbs{}table}
\PYG{c+cm}{   * ====================================  ========== ============= =======}
\PYG{c+cm}{   * Key string                            Value type Default value Units}
\PYG{c+cm}{   * ====================================  ========== ============= =======}
\PYG{c+cm}{   * Gesture.Swipe.MinLength               float      150           mm}
\PYG{c+cm}{   * Gesture.Swipe.MinVelocity             float      1000          mm/s}
\PYG{c+cm}{   * ====================================  ========== ============= =======}
\PYG{c+cm}{   * \PYGZbs{}endtable}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * The following example demonstrates how to set the swipe configuration}
\PYG{c+cm}{   * parameters:}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * \PYGZbs{}include Gesture\PYGZus{}Swipe\PYGZus{}Params.txt}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * The Controller object must be connected to the Leap Motion service/daemon}
\PYG{c+cm}{   * before setting the configuration parameters.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * @since 1.0}
\PYG{c+cm}{   */}
  \PYG{k}{class} \PYG{n+nc}{SwipeGesture} \PYG{o}{:} \PYG{k}{public} \PYG{n}{Gesture}
  \PYG{p}{\PYGZob{}}
  \PYG{k}{public}\PYG{o}{:}
    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The swipe gesture type.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include SwipeGesture\PYGZus{}classType.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns Type The type value designating a swipe gesture.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{k}{static} \PYG{n}{Type} \PYG{n}{classType}\PYG{p}{()} \PYG{p}{\PYGZob{}} \PYG{k}{return} \PYG{n}{TYPE\PYGZus{}SWIPE}\PYG{p}{;} \PYG{p}{\PYGZcb{}}

    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{SwipeGesture}\PYG{p}{();}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Constructs a SwipeGesture object from an instance of the Gesture class.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include SwipeGesture\PYGZus{}SwipeGesture.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param rhs The Gesture instance to specialize. This Gesture instance must}
\PYG{c+cm}{     * be a SwipeGesture object.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n+nf}{SwipeGesture}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Gesture}\PYG{o}{\PYGZam{}} \PYG{n}{rhs}\PYG{p}{);}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The position where the swipe began.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include SwipeGesture\PYGZus{}startPosition.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns Vector The starting position within the Leap Motion frame of}
\PYG{c+cm}{     * reference, in mm.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Vector} \PYG{n+nf}{startPosition}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The current position of the swipe.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include SwipeGesture\PYGZus{}position.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns Vector The current swipe position within the Leap Motion frame of}
\PYG{c+cm}{     * reference, in mm.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Vector} \PYG{n+nf}{position}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The unit direction vector parallel to the swipe motion.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include SwipeGesture\PYGZus{}direction.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * You can compare the components of the vector to classify the swipe as}
\PYG{c+cm}{     * appropriate for your application. For example, if you are using swipes}
\PYG{c+cm}{     * for two dimensional scrolling, you can compare the x and y values to}
\PYG{c+cm}{     * determine if the swipe is primarily horizontal or vertical.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns Vector The unit direction vector representing the swipe}
\PYG{c+cm}{     * motion.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Vector} \PYG{n+nf}{direction}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The swipe speed in mm/second.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include SwipeGesture\PYGZus{}speed.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns float The speed of the finger performing the swipe gesture in}
\PYG{c+cm}{     * millimeters per second.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{float} \PYG{n+nf}{speed}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The finger performing the swipe gesture.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include SwipeGesture\PYGZus{}pointable.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns Pointable A Pointable object representing the swiping finger.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Pointable} \PYG{n+nf}{pointable}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}
  \PYG{p}{\PYGZcb{};}

  \PYG{c+cm}{/**}
\PYG{c+cm}{   * The CircleGesture classes represents a circular finger movement.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * A circle movement is recognized when the tip of a finger draws a circle}
\PYG{c+cm}{   * within the Leap Motion Controller field of view.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * \PYGZbs{}image html images/Leap\PYGZus{}Gesture\PYGZus{}Circle.png}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * **Important:** To use circle gestures in your application, you must enable}
\PYG{c+cm}{   * recognition of the circle gesture. You can enable recognition with:}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * \PYGZbs{}include Gesture\PYGZus{}Circle\PYGZus{}Enable.txt}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * Circle gestures are continuous. The CircleGesture objects for the gesture have}
\PYG{c+cm}{   * three possible states:}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * **State::STATE\PYGZus{}START** \PYGZhy{}\PYGZhy{} The circle gesture has just started. The movement has}
\PYG{c+cm}{   *   progressed far enough for the recognizer to classify it as a circle.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * **State::STATE\PYGZus{}UPDATE** \PYGZhy{}\PYGZhy{} The circle gesture is continuing.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * **State::STATE\PYGZus{}STOP** \PYGZhy{}\PYGZhy{} The circle gesture is finished.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * You can set the minimum radius and minimum arc length required for a movement}
\PYG{c+cm}{   * to be recognized as a circle using the config attribute of a connected}
\PYG{c+cm}{   * Controller object. Use the following keys to configure circle recognition:}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * \PYGZbs{}table}
\PYG{c+cm}{   * ====================================  ========== ============= =======}
\PYG{c+cm}{   * Key string                            Value type Default value Units}
\PYG{c+cm}{   * ====================================  ========== ============= =======}
\PYG{c+cm}{   * Gesture.Circle.MinRadius              float      5.0           mm}
\PYG{c+cm}{   * Gesture.Circle.MinArc                 float      1.5 * pi      radians}
\PYG{c+cm}{   * ====================================  ========== ============= =======}
\PYG{c+cm}{   * \PYGZbs{}endtable}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * The following example demonstrates how to set the circle configuration}
\PYG{c+cm}{   * parameters:}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * \PYGZbs{}include Gesture\PYGZus{}Circle\PYGZus{}Params.txt}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * The Controller object must be connected to the Leap Motion service/daemon}
\PYG{c+cm}{   * before setting the configuration parameters.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * @since 1.0}
\PYG{c+cm}{   */}
  \PYG{k}{class} \PYG{n+nc}{CircleGesture} \PYG{o}{:} \PYG{k}{public} \PYG{n}{Gesture}
  \PYG{p}{\PYGZob{}}
  \PYG{k}{public}\PYG{o}{:}
    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The circle gesture type.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include CircleGesture\PYGZus{}classType.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns Type The type value designating a circle gesture.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{k}{static} \PYG{n}{Type} \PYG{n}{classType}\PYG{p}{()} \PYG{p}{\PYGZob{}} \PYG{k}{return} \PYG{n}{TYPE\PYGZus{}CIRCLE}\PYG{p}{;} \PYG{p}{\PYGZcb{}}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Constructs a new CircleGesture object.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * An uninitialized CircleGesture object is considered invalid. Get valid instances}
\PYG{c+cm}{     * of the CircleGesture class from a Frame object.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{CircleGesture}\PYG{p}{();}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Constructs a CircleGesture object from an instance of the Gesture class.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include CircleGesture\PYGZus{}CircleGesture.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param rhs The Gesture instance to specialize. This Gesture instance must}
\PYG{c+cm}{     * be a CircleGesture object.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n+nf}{CircleGesture}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Gesture}\PYG{o}{\PYGZam{}} \PYG{n}{rhs}\PYG{p}{);}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The center point of the circle within the Leap Motion frame of reference.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include CircleGesture\PYGZus{}center.txt}
\PYG{c+cm}{     * @returns Vector The center of the circle in mm from the Leap Motion origin.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Vector} \PYG{n+nf}{center}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Returns the normal vector for the circle being traced.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * If you draw the circle clockwise, the normal vector points in the same}
\PYG{c+cm}{     * general direction as the pointable object drawing the circle. If you draw}
\PYG{c+cm}{     * the circle counterclockwise, the normal points back toward the}
\PYG{c+cm}{     * pointable. If the angle between the normal and the pointable object}
\PYG{c+cm}{     * drawing the circle is less than 90 degrees, then the circle is clockwise.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Gesture\PYGZus{}Circle\PYGZus{}Direction.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @return Vector the normal vector for the circle being traced}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Vector} \PYG{n+nf}{normal}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The number of times the finger tip has traversed the circle.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Progress is reported as a positive number of the number. For example,}
\PYG{c+cm}{     * a progress value of .5 indicates that the finger has gone halfway}
\PYG{c+cm}{     * around, while a value of 3 indicates that the finger has gone around}
\PYG{c+cm}{     * the the circle three times.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include CircleGesture\PYGZus{}progress.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Progress starts where the circle gesture began. Since the circle}
\PYG{c+cm}{     * must be partially formed before the Leap Motion software can recognize it, progress}
\PYG{c+cm}{     * will be greater than zero when a circle gesture first appears in the}
\PYG{c+cm}{     * frame.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns float A positive number indicating the gesture progress.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{float} \PYG{n+nf}{progress}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The radius of the circle.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include CircleGesture\PYGZus{}radius.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The circle radius in mm.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{float} \PYG{n+nf}{radius}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The finger performing the circle gesture.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include CircleGesture\PYGZus{}pointable.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns Pointable A Pointable object representing the circling finger.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Pointable} \PYG{n+nf}{pointable}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}
  \PYG{p}{\PYGZcb{};}

  \PYG{c+cm}{/**}
\PYG{c+cm}{   * The ScreenTapGesture class represents a tapping gesture by a finger or tool.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * A screen tap gesture is recognized when the tip of a finger pokes forward}
\PYG{c+cm}{   * and then springs back to approximately the original position, as if}
\PYG{c+cm}{   * tapping a vertical screen. The tapping finger must pause briefly before beginning the tap.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * \PYGZbs{}image html images/Leap\PYGZus{}Gesture\PYGZus{}Tap2.png}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * **Important:** To use screen tap gestures in your application, you must enable}
\PYG{c+cm}{   * recognition of the screen tap gesture. You can enable recognition with:}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * \PYGZbs{}include Gesture\PYGZus{}ScreenTap\PYGZus{}Enable.txt}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * ScreenTap gestures are discrete. The ScreenTapGesture object representing a tap always}
\PYG{c+cm}{   * has the state, STATE\PYGZus{}STOP. Only one ScreenTapGesture object is created for each}
\PYG{c+cm}{   * screen tap gesture recognized.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * You can set the minimum finger movement and velocity required for a movement}
\PYG{c+cm}{   * to be recognized as a screen tap as well as adjust the detection window for}
\PYG{c+cm}{   * evaluating the movement using the config attribute of a connected}
\PYG{c+cm}{   * Controller object. Use the following keys to configure screen tap recognition:}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * \PYGZbs{}table}
\PYG{c+cm}{   * ====================================  ========== ============= =======}
\PYG{c+cm}{   * Key string                            Value type Default value Units}
\PYG{c+cm}{   * ====================================  ========== ============= =======}
\PYG{c+cm}{   * Gesture.ScreenTap.MinForwardVelocity  float      50            mm/s}
\PYG{c+cm}{   * Gesture.ScreenTap.HistorySeconds      float      0.1           s}
\PYG{c+cm}{   * Gesture.ScreenTap.MinDistance         float      5.0           mm}
\PYG{c+cm}{   * ====================================  ========== ============= =======}
\PYG{c+cm}{   * \PYGZbs{}endtable}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * The following example demonstrates how to set the screen tap configuration}
\PYG{c+cm}{   * parameters:}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * \PYGZbs{}include Gesture\PYGZus{}ScreenTap\PYGZus{}Params.txt}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * The Controller object must be connected to the Leap Motion service/daemon}
\PYG{c+cm}{   * before setting the configuration parameters.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * @since 1.0}
\PYG{c+cm}{   */}
  \PYG{k}{class} \PYG{n+nc}{ScreenTapGesture} \PYG{o}{:} \PYG{k}{public} \PYG{n}{Gesture}
  \PYG{p}{\PYGZob{}}
  \PYG{k}{public}\PYG{o}{:}
    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The screen tap gesture type.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include ScreenTapGesture\PYGZus{}classType.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns Type The type value designating a screen tap gesture.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{k}{static} \PYG{n}{Type} \PYG{n}{classType}\PYG{p}{()} \PYG{p}{\PYGZob{}} \PYG{k}{return} \PYG{n}{TYPE\PYGZus{}SCREEN\PYGZus{}TAP}\PYG{p}{;} \PYG{p}{\PYGZcb{}}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Constructs a new ScreenTapGesture object.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * An uninitialized ScreenTapGesture object is considered invalid. Get valid instances}
\PYG{c+cm}{     * of the ScreenTapGesture class from a Frame object.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{ScreenTapGesture}\PYG{p}{();}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Constructs a ScreenTapGesture object from an instance of the Gesture class.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include ScreenTapGesture\PYGZus{}ScreenTapGesture.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param rhs The Gesture instance to specialize. This Gesture instance must}
\PYG{c+cm}{     * be a ScreenTapGesture object.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n+nf}{ScreenTapGesture}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Gesture}\PYG{o}{\PYGZam{}} \PYG{n}{rhs}\PYG{p}{);}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The position where the screen tap is registered.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include ScreenTapGesture\PYGZus{}position.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @return Vector A Vector containing the coordinates of screen tap location.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Vector} \PYG{n+nf}{position}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The direction of finger tip motion.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include ScreenTapGesture\PYGZus{}direction.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns Vector A unit direction vector.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Vector} \PYG{n+nf}{direction}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The progress value is always 1.0 for a screen tap gesture.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns float The value 1.0.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{float} \PYG{n+nf}{progress}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The finger performing the screen tap gesture.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include ScreenTapGesture\PYGZus{}pointable.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns Pointable A Pointable object representing the tapping finger.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Pointable} \PYG{n+nf}{pointable}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}
  \PYG{p}{\PYGZcb{};}

  \PYG{c+cm}{/**}
\PYG{c+cm}{   * The KeyTapGesture class represents a tapping gesture by a finger or tool.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * A key tap gesture is recognized when the tip of a finger rotates down toward the}
\PYG{c+cm}{   * palm and then springs back to approximately the original position, as if}
\PYG{c+cm}{   * tapping. The tapping finger must pause briefly before beginning the tap.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * \PYGZbs{}image html images/Leap\PYGZus{}Gesture\PYGZus{}Tap.png}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * **Important:** To use key tap gestures in your application, you must enable}
\PYG{c+cm}{   * recognition of the key tap gesture. You can enable recognition with:}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * \PYGZbs{}include Gesture\PYGZus{}KeyTap\PYGZus{}Enable.txt}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * Key tap gestures are discrete. The KeyTapGesture object representing a tap always}
\PYG{c+cm}{   * has the state, STATE\PYGZus{}STOP. Only one KeyTapGesture object is created for each}
\PYG{c+cm}{   * key tap gesture recognized.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * You can set the minimum finger movement and velocity required for a movement}
\PYG{c+cm}{   * to be recognized as a key tap as well as adjust the detection window for}
\PYG{c+cm}{   * evaluating the movement using the config attribute of a connected}
\PYG{c+cm}{   * Controller object. Use the following configuration keys to configure key tap}
\PYG{c+cm}{   * recognition:}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * \PYGZbs{}table}
\PYG{c+cm}{   * ====================================  ========== ============= =======}
\PYG{c+cm}{   * Key string                            Value type Default value Units}
\PYG{c+cm}{   * ====================================  ========== ============= =======}
\PYG{c+cm}{   * Gesture.KeyTap.MinDownVelocity        float      50            mm/s}
\PYG{c+cm}{   * Gesture.KeyTap.HistorySeconds         float      0.1           s}
\PYG{c+cm}{   * Gesture.KeyTap.MinDistance            float      3.0           mm}
\PYG{c+cm}{   * ====================================  ========== ============= =======}
\PYG{c+cm}{   * \PYGZbs{}endtable}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * The following example demonstrates how to set the key tap configuration}
\PYG{c+cm}{   * parameters:}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * \PYGZbs{}include Gesture\PYGZus{}KeyTap\PYGZus{}Params.txt}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * The Controller object must be connected to the Leap Motion service/daemon}
\PYG{c+cm}{   * before setting the configuration parameters.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * @since 1.0}
\PYG{c+cm}{   */}
  \PYG{k}{class} \PYG{n+nc}{KeyTapGesture} \PYG{o}{:} \PYG{k}{public} \PYG{n}{Gesture}
  \PYG{p}{\PYGZob{}}
  \PYG{k}{public}\PYG{o}{:}
    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The key tap gesture type.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include KeyTapGesture\PYGZus{}classType.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns Type The type value designating a key tap gesture.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{k}{static} \PYG{n}{Type} \PYG{n}{classType}\PYG{p}{()} \PYG{p}{\PYGZob{}} \PYG{k}{return} \PYG{n}{TYPE\PYGZus{}KEY\PYGZus{}TAP}\PYG{p}{;} \PYG{p}{\PYGZcb{}}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Constructs a new KeyTapGesture object.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * An uninitialized KeyTapGesture object is considered invalid. Get valid instances}
\PYG{c+cm}{     * of the KeyTapGesture class from a Frame object.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{KeyTapGesture}\PYG{p}{();}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Constructs a KeyTapGesture object from an instance of the Gesture class.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include KeyTapGesture\PYGZus{}KeyTapGesture.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param rhs The Gesture instance to specialize. This Gesture instance must}
\PYG{c+cm}{     * be a KeyTapGesture object.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n+nf}{KeyTapGesture}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Gesture}\PYG{o}{\PYGZam{}} \PYG{n}{rhs}\PYG{p}{);}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The position where the key tap is registered.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include KeyTapGesture\PYGZus{}position.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @return Vector A Vector containing the coordinates of tap location.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Vector} \PYG{n+nf}{position}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The direction of finger tip motion.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include KeyTapGesture\PYGZus{}direction.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns Vector A unit direction vector if the finger tip is moving;}
\PYG{c+cm}{     * otherwise, a zero\PYGZhy{}vector.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Vector} \PYG{n+nf}{direction}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The progress value is always 1.0 for a key tap gesture.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns float The value 1.0.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{float} \PYG{n+nf}{progress}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The finger performing the key tap gesture.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include KeyTapGesture\PYGZus{}pointable.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns Pointable A Pointable object representing the tapping finger.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Pointable} \PYG{n+nf}{pointable}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}
  \PYG{p}{\PYGZcb{};}

  \PYG{c+cm}{/*}
\PYG{c+cm}{   * Deprecated as of version 1.2.}
\PYG{c+cm}{   */}
  \PYG{k}{class} \PYG{n+nc}{Screen} \PYG{o}{:} \PYG{k}{public} \PYG{n}{Interface} \PYG{p}{\PYGZob{}}
  \PYG{k}{public}\PYG{o}{:}
    \PYG{c+c1}{// For internal use only.}
    \PYG{n}{Screen}\PYG{p}{(}\PYG{n}{ScreenImplementation}\PYG{o}{*}\PYG{p}{);}

    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n+nf}{Screen}\PYG{p}{();}

    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{int32\PYGZus{}t} \PYG{n+nf}{id}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Vector} \PYG{n+nf}{intersect}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Pointable}\PYG{o}{\PYGZam{}} \PYG{n}{pointable}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{n}{normalize}\PYG{p}{,} \PYG{k+kt}{float} \PYG{n}{clampRatio} \PYG{o}{=} \PYG{l+m+mf}{1.0f}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Vector} \PYG{n+nf}{intersect}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZam{}} \PYG{n}{position}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZam{}} \PYG{n}{direction}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{n}{normalize}\PYG{p}{,} \PYG{k+kt}{float} \PYG{n}{clampRatio} \PYG{o}{=} \PYG{l+m+mf}{1.0f}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Vector} \PYG{n+nf}{project}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZam{}} \PYG{n}{position}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{n}{normalize}\PYG{p}{,} \PYG{k+kt}{float} \PYG{n}{clampRatio} \PYG{o}{=} \PYG{l+m+mf}{1.0f}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Vector} \PYG{n+nf}{horizontalAxis}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Vector} \PYG{n+nf}{verticalAxis}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Vector} \PYG{n+nf}{bottomLeftCorner}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Vector} \PYG{n+nf}{normal}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{int} \PYG{n+nf}{widthPixels}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{int} \PYG{n+nf}{heightPixels}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{float} \PYG{n+nf}{distanceToPoint}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZam{}} \PYG{n}{point}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{n+nf}{isValid}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{static} \PYG{k}{const} \PYG{n}{Screen}\PYG{o}{\PYGZam{}} \PYG{n}{invalid}\PYG{p}{();}

    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{k}{operator}\PYG{o}{==}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Screen}\PYG{o}{\PYGZam{}}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{k}{operator}\PYG{o}{!=}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Screen}\PYG{o}{\PYGZam{}}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{friend} \PYG{n}{std}\PYG{o}{::}\PYG{n}{ostream}\PYG{o}{\PYGZam{}} \PYG{k}{operator}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{p}{(}\PYG{n}{std}\PYG{o}{::}\PYG{n}{ostream}\PYG{o}{\PYGZam{}}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Screen}\PYG{o}{\PYGZam{}}\PYG{p}{);}

    \PYG{n}{std}\PYG{o}{::}\PYG{n}{string} \PYG{n}{toString}\PYG{p}{()} \PYG{k}{const} \PYG{p}{\PYGZob{}}
      \PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{cstr} \PYG{o}{=} \PYG{n}{toCString}\PYG{p}{();}
      \PYG{n}{std}\PYG{o}{::}\PYG{n}{string} \PYG{n}{str}\PYG{p}{(}\PYG{n}{cstr}\PYG{p}{);}
      \PYG{n}{deleteCString}\PYG{p}{(}\PYG{n}{cstr}\PYG{p}{);}
      \PYG{k}{return} \PYG{n}{str}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

  \PYG{k}{private}\PYG{o}{:}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{toCString}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}
  \PYG{p}{\PYGZcb{};}

  \PYG{c+cm}{/**}
\PYG{c+cm}{   * The Device class represents a physically connected device.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * The Device class contains information related to a particular connected}
\PYG{c+cm}{   * device such as device id, field of view relative to the device,}
\PYG{c+cm}{   * and the position and orientation of the device in relative coordinates.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * The position and orientation describe the alignment of the device relative to the user.}
\PYG{c+cm}{   * The alignment relative to the user is only descriptive. Aligning devices to users}
\PYG{c+cm}{   * provides consistency in the parameters that describe user interactions.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * Note that Device objects can be invalid, which means that they do not contain}
\PYG{c+cm}{   * valid device information and do not correspond to a physical device.}
\PYG{c+cm}{   * Test for validity with the Device::isValid() function.}
\PYG{c+cm}{   * @since 1.0}
\PYG{c+cm}{   */}
  \PYG{k}{class} \PYG{n+nc}{Device} \PYG{o}{:} \PYG{k}{public} \PYG{n}{Interface} \PYG{p}{\PYGZob{}}
  \PYG{k}{public}\PYG{o}{:}

  \PYG{c+cm}{/**}
\PYG{c+cm}{   * The available types of Leap Motion controllers.}
\PYG{c+cm}{   * @since 1.2}
\PYG{c+cm}{   */}
    \PYG{k}{enum} \PYG{n}{Type}
    \PYG{p}{\PYGZob{}}
    \PYG{c+cm}{/**}
\PYG{c+cm}{     * A standalone USB peripheral. The original Leap Motion controller device.}
\PYG{c+cm}{     * @since 1.2}
\PYG{c+cm}{     */}
      \PYG{n}{TYPE\PYGZus{}PERIPHERAL} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,}
    \PYG{c+cm}{/**}
\PYG{c+cm}{     * A controller embedded in a keyboard.}
\PYG{c+cm}{     * @since 1.2}
\PYG{c+cm}{     */}
      \PYG{n}{TYPE\PYGZus{}LAPTOP}\PYG{p}{,}
    \PYG{c+cm}{/**}
\PYG{c+cm}{     * A controller embedded in a laptop computer.}
\PYG{c+cm}{     * @since 1.2}
\PYG{c+cm}{     */}
      \PYG{n}{TYPE\PYGZus{}KEYBOARD}
    \PYG{p}{\PYGZcb{};}

    \PYG{c+c1}{// For internal use only.}
    \PYG{n}{Device}\PYG{p}{(}\PYG{n}{DeviceImplementation}\PYG{o}{*}\PYG{p}{);}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Constructs a Device object.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * An uninitialized device is considered invalid.}
\PYG{c+cm}{     * Get valid Device objects from a DeviceList object obtained using the}
\PYG{c+cm}{     * Controller::devices() method.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Device\PYGZus{}Device.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n+nf}{Device}\PYG{p}{();}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The angle of view along the x axis of this device.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}image html images/Leap\PYGZus{}horizontalViewAngle.png}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * The Leap Motion controller scans a region in the shape of an inverted pyramid}
\PYG{c+cm}{     * centered at the device\PYGZsq{}s center and extending upwards. The horizontalViewAngle}
\PYG{c+cm}{     * reports the view angle along the long dimension of the device.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Device\PYGZus{}horizontalViewAngle.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The horizontal angle of view in radians.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{float} \PYG{n+nf}{horizontalViewAngle}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The angle of view along the z axis of this device.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}image html images/Leap\PYGZus{}verticalViewAngle.png}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * The Leap Motion controller scans a region in the shape of an inverted pyramid}
\PYG{c+cm}{     * centered at the device\PYGZsq{}s center and extending upwards. The verticalViewAngle}
\PYG{c+cm}{     * reports the view angle along the short dimension of the device.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Device\PYGZus{}verticalViewAngle.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The vertical angle of view in radians.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{float} \PYG{n+nf}{verticalViewAngle}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The maximum reliable tracking range from the center of this device.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * The range reports the maximum recommended distance from the device center}
\PYG{c+cm}{     * for which tracking is expected to be reliable. This distance is not a hard limit.}
\PYG{c+cm}{     * Tracking may be still be functional above this distance or begin to degrade slightly}
\PYG{c+cm}{     * before this distance depending on calibration and extreme environmental conditions.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Device\PYGZus{}range.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The recommended maximum range of the device in mm.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{float} \PYG{n+nf}{range}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The distance between the center points of the stereo sensors.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * The baseline value, together with the maximum resolution, influence the}
\PYG{c+cm}{     * maximum range.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The separation distance between the center of each sensor, in mm.}
\PYG{c+cm}{     * @since 2.2.5}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{float} \PYG{n+nf}{baseline}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The distance to the nearest edge of the Leap Motion controller\PYGZsq{}s view volume.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * The view volume is an axis\PYGZhy{}aligned, inverted pyramid centered on the device origin}
\PYG{c+cm}{     * and extending upward to the range limit. The walls of the pyramid are described}
\PYG{c+cm}{     * by the horizontalViewAngle and verticalViewAngle and the roof by the range.}
\PYG{c+cm}{     * This function estimates the distance between the specified input position and the}
\PYG{c+cm}{     * nearest wall or roof of the view volume.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Device\PYGZus{}distanceToBoundary.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param position The point to use for the distance calculation.}
\PYG{c+cm}{     * @returns The distance in millimeters from the input position to the nearest boundary.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{float} \PYG{n+nf}{distanceToBoundary}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZam{}} \PYG{n}{position}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Reports whether this device is embedded in another computer or computer}
\PYG{c+cm}{     * peripheral.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns True, if this device is embedded in a laptop, keyboard, or other computer}
\PYG{c+cm}{     * component; false, if this device is a standalone controller.}
\PYG{c+cm}{     * @since 1.2}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{n+nf}{isEmbedded}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Reports whether this device is streaming data to your application.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Currently only one controller can provide data at a time.}
\PYG{c+cm}{     * @since 1.2}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{n+nf}{isStreaming}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+c1}{// primarily for the image API}
    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Deprecated. Always reports false.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @since 2.1}
\PYG{c+cm}{     * @deprecated 2.1.1}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{n+nf}{isFlipped}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The device type.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Use the device type value in the (rare) circumstances that you}
\PYG{c+cm}{     * have an application feature which relies on a particular type of device.}
\PYG{c+cm}{     * Current types of device include the original Leap Motion peripheral,}
\PYG{c+cm}{     * keyboard\PYGZhy{}embedded controllers, and laptop\PYGZhy{}embedded controllers.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The physical device type as a member of the DeviceType enumeration.}
\PYG{c+cm}{     * @since 1.2}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Type} \PYG{n+nf}{type}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * An alphanumeric serial number unique to each device.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Consumer device serial numbers consist of 2 letters followed by 11 digits.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * When using multiple devices, the serial number provides an unambiguous}
\PYG{c+cm}{     * identifier for each device.}
\PYG{c+cm}{     * @since 2.2.2}
\PYG{c+cm}{     */}
    \PYG{n}{std}\PYG{o}{::}\PYG{n}{string} \PYG{n}{serialNumber}\PYG{p}{()} \PYG{k}{const} \PYG{p}{\PYGZob{}}
      \PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{cstr} \PYG{o}{=} \PYG{n}{serialNumberCString}\PYG{p}{();}
      \PYG{n}{std}\PYG{o}{::}\PYG{n}{string} \PYG{n}{str}\PYG{p}{(}\PYG{n}{cstr}\PYG{p}{);}
      \PYG{n}{deleteCString}\PYG{p}{(}\PYG{n}{cstr}\PYG{p}{);}
      \PYG{k}{return} \PYG{n}{str}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+cm}{/*}
\PYG{c+cm}{     * This API is experimental and not currently intended for external use.}
\PYG{c+cm}{     * Position and orientation can only be manually configured via a config file.}
\PYG{c+cm}{     * This API and the config file may change in the future or be removed entirely.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * The position of the center of the device in global coordinates (currently defined}
\PYG{c+cm}{     * in the configuration file).}
\PYG{c+cm}{     * @since 2.2.2}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Vector} \PYG{n}{position}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/*}
\PYG{c+cm}{     * This API is experimental and not currently intended for external use.}
\PYG{c+cm}{     * Position and orientation can only be manually configured via a config file.}
\PYG{c+cm}{     * This API and the config file may change in the future or be removed entirely.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * The orientation of the device is described by a right\PYGZhy{}handed basis:}
\PYG{c+cm}{     * xBasis : Unit vector along baseline axis between camera centers}
\PYG{c+cm}{     * yBasis : Unit vector in the direction of the center of view of both cameras}
\PYG{c+cm}{     * zBasis : The completion of the right\PYGZhy{}handed basis (perpendicular to the}
\PYG{c+cm}{     *          x and y vectors)}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * In the case of a peripheral device, the z\PYGZhy{}basis vector points}
\PYG{c+cm}{     * out from the green\PYGZhy{}status\PYGZhy{}LED side of the device. When multiple\PYGZhy{}device}
\PYG{c+cm}{     * tracking is enabled, automatic coordinate system orientation is disabled.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}image html images/Leap\PYGZus{}Axes.png}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @since 2.2.2}
\PYG{c+cm}{    */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Matrix} \PYG{n+nf}{orientation}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Reports whether this is a valid Device object.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Device\PYGZus{}isValid.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns True, if this Device object contains valid data.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{n+nf}{isValid}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Returns an invalid Device object.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * You can use the instance returned by this function in comparisons testing}
\PYG{c+cm}{     * whether a given Device instance is valid or invalid. (You can also use the}
\PYG{c+cm}{     * Device::isValid() function.)}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Device\PYGZus{}invalid.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The invalid Device instance.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{static} \PYG{k}{const} \PYG{n}{Device}\PYG{o}{\PYGZam{}} \PYG{n}{invalid}\PYG{p}{();}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Compare Device object equality.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Device\PYGZus{}operator\PYGZus{}equals.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Two Device objects are equal if and only if both Device objects represent the}
\PYG{c+cm}{     * exact same Device and both Devices are valid.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{k}{operator}\PYG{o}{==}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Device}\PYG{o}{\PYGZam{}}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Compare Device object inequality.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Device\PYGZus{}operator\PYGZus{}not\PYGZus{}equals.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Two Device objects are equal if and only if both Device objects represent the}
\PYG{c+cm}{     * exact same Device and both Devices are valid.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{k}{operator}\PYG{o}{!=}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Device}\PYG{o}{\PYGZam{}}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Writes a brief, human readable description of the Device object.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Device\PYGZus{}operator\PYGZus{}stream.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{friend} \PYG{n}{std}\PYG{o}{::}\PYG{n}{ostream}\PYG{o}{\PYGZam{}} \PYG{k}{operator}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{p}{(}\PYG{n}{std}\PYG{o}{::}\PYG{n}{ostream}\PYG{o}{\PYGZam{}}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Device}\PYG{o}{\PYGZam{}}\PYG{p}{);}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * A string containing a brief, human readable description of the Device object.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns A description of the Device as a string.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{std}\PYG{o}{::}\PYG{n}{string} \PYG{n}{toString}\PYG{p}{()} \PYG{k}{const} \PYG{p}{\PYGZob{}}
      \PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{cstr} \PYG{o}{=} \PYG{n}{toCString}\PYG{p}{();}
      \PYG{n}{std}\PYG{o}{::}\PYG{n}{string} \PYG{n}{str}\PYG{p}{(}\PYG{n}{cstr}\PYG{p}{);}
      \PYG{n}{deleteCString}\PYG{p}{(}\PYG{n}{cstr}\PYG{p}{);}
      \PYG{k}{return} \PYG{n}{str}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

  \PYG{k}{private}\PYG{o}{:}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{toCString}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n+nf}{serialNumberCString}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}
  \PYG{p}{\PYGZcb{};}

  \PYG{c+cm}{/**}
\PYG{c+cm}{   * The Image class represents a single image from one of the Leap Motion cameras.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * In addition to image data, the Image object provides a distortion map for correcting}
\PYG{c+cm}{   * lens distortion.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * \PYGZbs{}include Image\PYGZus{}raw.txt}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * Note that Image objects can be invalid, which means that they do not contain}
\PYG{c+cm}{   * valid image data. Get valid Image objects from Frame::frames(). Test for}
\PYG{c+cm}{   * validity with the Image::isValid() function.}
\PYG{c+cm}{   * @since 2.1.0}
\PYG{c+cm}{   */}
  \PYG{k}{class} \PYG{n+nc}{Image} \PYG{o}{:} \PYG{k}{public} \PYG{n}{Interface} \PYG{p}{\PYGZob{}}
  \PYG{k}{public}\PYG{o}{:}

    \PYG{c+c1}{// For internal use only.}
    \PYG{n}{Image}\PYG{p}{(}\PYG{n}{ImageImplementation}\PYG{o}{*}\PYG{p}{);}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Constructs a Image object.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * An uninitialized image is considered invalid.}
\PYG{c+cm}{     * Get valid Image objects from a ImageList object obtained from the}
\PYG{c+cm}{     * Frame::images() method.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @since 2.1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n+nf}{Image}\PYG{p}{();}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The image sequence ID.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Image\PYGZus{}sequenceId.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @since 2.2.1}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{int64\PYGZus{}t} \PYG{n+nf}{sequenceId}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The image ID.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Images with ID of 0 are from the left camera; those with an ID of 1 are from the}
\PYG{c+cm}{     * right camera (with the device in its standard operating position with the}
\PYG{c+cm}{     * green LED facing the operator).}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @since 2.1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{int32\PYGZus{}t} \PYG{n+nf}{id}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The image data.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * The image data is a set of 8\PYGZhy{}bit intensity values. The buffer is}
\PYG{c+cm}{     * ``Image::width() * Image::height() * Image::bytesPerPixel()`` bytes long.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Image\PYGZus{}data\PYGZus{}1.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @return The array of unsigned char containing the sensor brightness values.}
\PYG{c+cm}{     * @since 2.1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n+nf}{data}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The distortion calibration map for this image.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * The calibration map is a 64x64 grid of points. Each point is defined by}
\PYG{c+cm}{     * a pair of 32\PYGZhy{}bit floating point values. Each point in the map}
\PYG{c+cm}{     * represents a ray projected into the camera. The value of}
\PYG{c+cm}{     * a grid point defines the pixel in the image data containing the brightness}
\PYG{c+cm}{     * value produced by the light entering along the corresponding ray. By}
\PYG{c+cm}{     * interpolating between grid data points, you can find the brightness value}
\PYG{c+cm}{     * for any projected ray. Grid values that fall outside the range [0..1] do}
\PYG{c+cm}{     * not correspond to a value in the image data and those points should be ignored.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Image\PYGZus{}distortion\PYGZus{}1.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * The calibration map can be used to render an undistorted image as well as to}
\PYG{c+cm}{     * find the true angle from the camera to a feature in the raw image. The}
\PYG{c+cm}{     * distortion map itself is designed to be used with GLSL shader programs.}
\PYG{c+cm}{     * In non\PYGZhy{}realtime contexts, it may be more convenient to use the Image::rectify()}
\PYG{c+cm}{     * and Image::warp() functions.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * If using shaders is not possible, you can use the distortion map directly.}
\PYG{c+cm}{     * This can be faster than using the ``warp()`` function, if carefully optimized:}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Image\PYGZus{}distortion\PYGZus{}using.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Distortion is caused by the lens geometry as well as imperfections in the}
\PYG{c+cm}{     * lens and sensor window. The calibration map is created by the calibration}
\PYG{c+cm}{     * process run for each device at the factory (and which can be rerun by the}
\PYG{c+cm}{     * user).}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Note, in a future release, there may be two distortion maps per image;}
\PYG{c+cm}{     * one containing the horizontal values and the other containing the vertical values.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The float array containing the camera lens distortion map.}
\PYG{c+cm}{     * @since 2.1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{const} \PYG{k+kt}{float}\PYG{o}{*} \PYG{n+nf}{distortion}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/*}
\PYG{c+cm}{     * Do not call this version of data(). It is intended only as a helper for C\PYGZsh{},}
\PYG{c+cm}{     * Java, and other languages. Use the primary version of data() which returns a}
\PYG{c+cm}{     * pointer.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @since 2.1.0}
\PYG{c+cm}{     */}
    \PYG{k+kt}{void} \PYG{n+nf}{data}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{dst}\PYG{p}{)} \PYG{k}{const} \PYG{p}{\PYGZob{}}
      \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{src} \PYG{o}{=} \PYG{n}{data}\PYG{p}{();}
      \PYG{n}{memcpy}\PYG{p}{(}\PYG{n}{dst}\PYG{p}{,} \PYG{n}{src}\PYG{p}{,} \PYG{n}{width}\PYG{p}{()} \PYG{o}{*} \PYG{n}{height}\PYG{p}{()} \PYG{o}{*} \PYG{n}{bytesPerPixel}\PYG{p}{()} \PYG{o}{*} \PYG{k}{sizeof}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{char}\PYG{p}{));}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+cm}{/*}
\PYG{c+cm}{     * Do not call this version of distortion(). It is intended only as a helper for C\PYGZsh{},}
\PYG{c+cm}{     * Java, and other languages. Use the primary version of distortion() which returns}
\PYG{c+cm}{     * a pointer.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @since 2.1.0}
\PYG{c+cm}{     */}
    \PYG{k+kt}{void} \PYG{n+nf}{distortion}\PYG{p}{(}\PYG{k+kt}{float}\PYG{o}{*} \PYG{n}{dst}\PYG{p}{)} \PYG{k}{const} \PYG{p}{\PYGZob{}}
      \PYG{k}{const} \PYG{k+kt}{float}\PYG{o}{*} \PYG{n}{src} \PYG{o}{=} \PYG{n}{distortion}\PYG{p}{();}
      \PYG{n}{memcpy}\PYG{p}{(}\PYG{n}{dst}\PYG{p}{,} \PYG{n}{src}\PYG{p}{,} \PYG{n}{distortionWidth}\PYG{p}{()} \PYG{o}{*} \PYG{n}{distortionHeight}\PYG{p}{()} \PYG{o}{*} \PYG{k}{sizeof}\PYG{p}{(}\PYG{k+kt}{float}\PYG{p}{));}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+cm}{/* Do not call dataPointer(). It is intended only as a helper for C\PYGZsh{}.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @since 2.2.7}
\PYG{c+cm}{     */}
    \PYG{k+kt}{void}\PYG{o}{*} \PYG{n+nf}{dataPointer}\PYG{p}{()} \PYG{k}{const} \PYG{p}{\PYGZob{}}
      \PYG{k}{return} \PYG{p}{(}\PYG{k+kt}{void}\PYG{o}{*}\PYG{p}{)} \PYG{n}{data}\PYG{p}{();}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+cm}{/* Do not call distortionPointer(). It is intended only as a helper for C\PYGZsh{}.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @since 2.2.7}
\PYG{c+cm}{     */}
    \PYG{k+kt}{void}\PYG{o}{*} \PYG{n+nf}{distortionPointer}\PYG{p}{()} \PYG{k}{const} \PYG{p}{\PYGZob{}}
      \PYG{k}{return} \PYG{p}{(}\PYG{k+kt}{void}\PYG{o}{*}\PYG{p}{)} \PYG{n}{distortion}\PYG{p}{();}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The image width.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Image\PYGZus{}image\PYGZus{}width\PYGZus{}1.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @since 2.1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{int} \PYG{n+nf}{width}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The image height.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Image\PYGZus{}image\PYGZus{}height\PYGZus{}1.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @since 2.1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{int} \PYG{n+nf}{height}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The number of bytes per pixel.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Use this value along with ``Image::width()`` and ``Image:::height()``}
\PYG{c+cm}{     * to calculate the size of the data buffer.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Image\PYGZus{}bytesPerPixel.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @since 2.2.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{int} \PYG{n+nf}{bytesPerPixel}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Enumerates the possible image formats.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * The Image::format() function returns an item from the FormatType enumeration.}
\PYG{c+cm}{     * @since 2.2.0}
\PYG{c+cm}{     */}
    \PYG{k}{enum} \PYG{n}{FormatType} \PYG{p}{\PYGZob{}}
      \PYG{n}{INFRARED} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{p}{\PYGZcb{};}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The image format.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Image\PYGZus{}format.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @since 2.2.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{FormatType} \PYG{n+nf}{format}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The stride of the distortion map.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Since each point on the 64x64 element distortion map has two values in the}
\PYG{c+cm}{     * buffer, the stride is 2 times the size of the grid. (Stride is currently fixed}
\PYG{c+cm}{     * at 2 * 64 = 128).}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Image\PYGZus{}distortion\PYGZus{}width\PYGZus{}1.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @since 2.1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{int} \PYG{n+nf}{distortionWidth}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The distortion map height.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Currently fixed at 64.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Image\PYGZus{}distortion\PYGZus{}height\PYGZus{}1.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @since 2.1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{int} \PYG{n+nf}{distortionHeight}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The horizontal ray offset.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Used to convert between normalized coordinates in the range [0..1] and the}
\PYG{c+cm}{     * ray slope range [\PYGZhy{}4..4].}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Image\PYGZus{}ray\PYGZus{}factors\PYGZus{}1.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @since 2.1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{float} \PYG{n+nf}{rayOffsetX}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The vertical ray offset.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Used to convert between normalized coordinates in the range [0..1] and the}
\PYG{c+cm}{     * ray slope range [\PYGZhy{}4..4].}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Image\PYGZus{}ray\PYGZus{}factors\PYGZus{}2.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @since 2.1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{float} \PYG{n+nf}{rayOffsetY}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The horizontal ray scale factor.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Used to convert between normalized coordinates in the range [0..1] and the}
\PYG{c+cm}{     * ray slope range [\PYGZhy{}4..4].}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Image\PYGZus{}ray\PYGZus{}factors\PYGZus{}1.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @since 2.1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{float} \PYG{n+nf}{rayScaleX}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The vertical ray scale factor.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Used to convert between normalized coordinates in the range [0..1] and the}
\PYG{c+cm}{     * ray slope range [\PYGZhy{}4..4].}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Image\PYGZus{}ray\PYGZus{}factors\PYGZus{}2.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @since 2.1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{float} \PYG{n+nf}{rayScaleY}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Provides the corrected camera ray intercepting the specified point on the image.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Given a point on the image, ``rectify()`` corrects for camera distortion}
\PYG{c+cm}{     * and returns the true direction from the camera to the source of that image point}
\PYG{c+cm}{     * within the Leap Motion field of view.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * This direction vector has an x and y component [x, y, 0], with the third element}
\PYG{c+cm}{     * always zero. Note that this vector uses the 2D camera coordinate system}
\PYG{c+cm}{     * where the x\PYGZhy{}axis parallels the longer (typically horizontal) dimension and}
\PYG{c+cm}{     * the y\PYGZhy{}axis parallels the shorter (vertical) dimension. The camera coordinate}
\PYG{c+cm}{     * system does not correlate to the 3D Leap Motion coordinate system.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Image\PYGZus{}rectify\PYGZus{}1.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param uv A Vector containing the position of a pixel in the image.}
\PYG{c+cm}{     * @returns A Vector containing the ray direction (the z\PYGZhy{}component of the vector is always 0).}
\PYG{c+cm}{     * @since 2.1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Vector} \PYG{n+nf}{rectify}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZam{}} \PYG{n}{uv}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;} \PYG{c+c1}{// returns a vector (x, y, 0). The z\PYGZhy{}component is ignored}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Provides the point in the image corresponding to a ray projecting}
\PYG{c+cm}{     * from the camera.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Given a ray projected from the camera in the specified direction, ``warp()``}
\PYG{c+cm}{     * corrects for camera distortion and returns the corresponding pixel}
\PYG{c+cm}{     * coordinates in the image.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * The ray direction is specified in relationship to the camera. The first}
\PYG{c+cm}{     * vector element corresponds to the \PYGZdq{}horizontal\PYGZdq{} view angle; the second}
\PYG{c+cm}{     * corresponds to the \PYGZdq{}vertical\PYGZdq{} view angle.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Image\PYGZus{}warp\PYGZus{}1.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * The ``warp()`` function returns pixel coordinates outside of the image bounds}
\PYG{c+cm}{     * if you project a ray toward a point for which there is no recorded data.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * ``warp()`` is typically not fast enough for realtime distortion correction.}
\PYG{c+cm}{     * For better performance, use a shader program exectued on a GPU.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param xy A Vector containing the ray direction.}
\PYG{c+cm}{     * @returns A Vector containing the pixel coordinates [x, y, 0] (with z always zero).}
\PYG{c+cm}{     * @since 2.1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Vector} \PYG{n+nf}{warp}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZam{}} \PYG{n}{xy}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;} \PYG{c+c1}{// returns vector (u, v, 0). The z\PYGZhy{}component is ignored}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Returns a timestamp indicating when this frame began being captured on the device.}
\PYG{c+cm}{     * }
\PYG{c+cm}{     * @since 2.2.7}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{int64\PYGZus{}t} \PYG{n+nf}{timestamp}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}
   
    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Reports whether this Image instance contains valid data.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns true, if and only if the image is valid.}
\PYG{c+cm}{     * @since 2.1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{n+nf}{isValid}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Returns an invalid Image object.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * You can use the instance returned by this function in comparisons testing}
\PYG{c+cm}{     * whether a given Image instance is valid or invalid. (You can also use the}
\PYG{c+cm}{     * Image::isValid() function.)}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The invalid Image instance.}
\PYG{c+cm}{     * @since 2.1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{static} \PYG{k}{const} \PYG{n}{Image}\PYG{o}{\PYGZam{}} \PYG{n}{invalid}\PYG{p}{();}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Compare Image object equality.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Two Image objects are equal if and only if both Image objects represent the}
\PYG{c+cm}{     * exact same Image and both Images are valid.}
\PYG{c+cm}{     * @since 2.1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{k}{operator}\PYG{o}{==}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Image}\PYG{o}{\PYGZam{}}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Compare Image object inequality.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Two Image objects are equal if and only if both Image objects represent the}
\PYG{c+cm}{     * exact same Image and both Images are valid.}
\PYG{c+cm}{     * @since 2.1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{k}{operator}\PYG{o}{!=}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Image}\PYG{o}{\PYGZam{}}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Writes a brief, human readable description of the Image object.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @since 2.1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{friend} \PYG{n}{std}\PYG{o}{::}\PYG{n}{ostream}\PYG{o}{\PYGZam{}} \PYG{k}{operator}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{p}{(}\PYG{n}{std}\PYG{o}{::}\PYG{n}{ostream}\PYG{o}{\PYGZam{}}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Image}\PYG{o}{\PYGZam{}}\PYG{p}{);}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * A string containing a brief, human readable description of the Image object.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns A description of the Image as a string.}
\PYG{c+cm}{     * @since 2.1.0}
\PYG{c+cm}{     */}
    \PYG{n}{std}\PYG{o}{::}\PYG{n}{string} \PYG{n}{toString}\PYG{p}{()} \PYG{k}{const} \PYG{p}{\PYGZob{}}
      \PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{cstr} \PYG{o}{=} \PYG{n}{toCString}\PYG{p}{();}
      \PYG{n}{std}\PYG{o}{::}\PYG{n}{string} \PYG{n}{str}\PYG{p}{(}\PYG{n}{cstr}\PYG{p}{);}
      \PYG{n}{deleteCString}\PYG{p}{(}\PYG{n}{cstr}\PYG{p}{);}
      \PYG{k}{return} \PYG{n}{str}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

  \PYG{k}{private}\PYG{o}{:}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{toCString}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}
  \PYG{p}{\PYGZcb{};}

  \PYG{c+cm}{/**}
\PYG{c+cm}{  * Note: This class is an experimental API for internal use only. It may be}
\PYG{c+cm}{  * removed without warning.}
\PYG{c+cm}{  *}
\PYG{c+cm}{  * A bitmap mask defining areas of an image in which a finger or part of a hand}
\PYG{c+cm}{  * is in front of the tracked quad. The mask is a subset of the camera image}
\PYG{c+cm}{  * containing a the region including the quad. Pixels in the mask representing}
\PYG{c+cm}{  * the hand have the value 255. Pixels in the rest of the mask have the value 0.}
\PYG{c+cm}{  *}
\PYG{c+cm}{  * Two masks are provided for every Leap Motion frame. The mask with the id of}
\PYG{c+cm}{  * 0 is for the left image. The right image has id 1.}
\PYG{c+cm}{  *}
\PYG{c+cm}{  * The mask corresponds to the uncorrected image from the camera sensor. If you}
\PYG{c+cm}{  * correct the image for distortion before displaying it, you should also correct}
\PYG{c+cm}{  * the mask.}
\PYG{c+cm}{  *}
\PYG{c+cm}{  * @since 2.2.6}
\PYG{c+cm}{  */}
  \PYG{k}{class} \PYG{n+nc}{Mask} \PYG{o}{:} \PYG{k}{public} \PYG{n}{Interface} \PYG{p}{\PYGZob{}}
  \PYG{k}{public}\PYG{o}{:}

    \PYG{c+c1}{// For internal use only.}
    \PYG{n}{Mask}\PYG{p}{(}\PYG{n}{MaskImplementation}\PYG{o}{*}\PYG{p}{);}

    \PYG{c+cm}{/**}
\PYG{c+cm}{    * Constructs a new Mask object. Do not use. Get Mask objects from TrackedQuad.}
\PYG{c+cm}{    * \PYGZbs{}include Mask\PYGZus{}constructor\PYGZus{}controller.txt}
\PYG{c+cm}{    * \PYGZbs{}include Mask\PYGZus{}constructor\PYGZus{}frame.txt}
\PYG{c+cm}{    * @since 2.2.6}
\PYG{c+cm}{    */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n+nf}{Mask}\PYG{p}{();}

    \PYG{c+cm}{/**}
\PYG{c+cm}{    * An id value based on the sequence in which the mask is produced. Corresponds}
\PYG{c+cm}{    * to the Image sequence id.}
\PYG{c+cm}{    * \PYGZbs{}include Mask\PYGZus{}sequenceId.txt}
\PYG{c+cm}{    * @since 2.2.6}
\PYG{c+cm}{    */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{int64\PYGZus{}t} \PYG{n+nf}{sequenceId}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{    * An id indicating whether the mask goes with the left (0) or right (1) image.}
\PYG{c+cm}{    * \PYGZbs{}include Mask\PYGZus{}id.txt}
\PYG{c+cm}{    * @since 2.2.6}
\PYG{c+cm}{    */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{int32\PYGZus{}t} \PYG{n+nf}{id}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{    * The pixels of the mask.}
\PYG{c+cm}{    *}
\PYG{c+cm}{    * Pixels with the value of 255 represent areas of the image where a finger}
\PYG{c+cm}{    * or part of a hand is in front of the quad. The rest of the mask has the}
\PYG{c+cm}{    * value 0.}
\PYG{c+cm}{    * \PYGZbs{}include Mask\PYGZus{}data.txt}
\PYG{c+cm}{    * @since 2.2.6}
\PYG{c+cm}{    */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n+nf}{data}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{data}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{dst}\PYG{p}{)} \PYG{k}{const} \PYG{p}{\PYGZob{}}
      \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{src} \PYG{o}{=} \PYG{n}{data}\PYG{p}{();}
      \PYG{n}{memcpy}\PYG{p}{(}\PYG{n}{dst}\PYG{p}{,} \PYG{n}{src}\PYG{p}{,} \PYG{n}{width}\PYG{p}{()} \PYG{o}{*} \PYG{n}{height}\PYG{p}{()} \PYG{o}{*} \PYG{k}{sizeof}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{char}\PYG{p}{));}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void}\PYG{o}{*} \PYG{n+nf}{dataPointer}\PYG{p}{()} \PYG{k}{const} \PYG{p}{\PYGZob{}}
      \PYG{k}{return} \PYG{p}{(}\PYG{k+kt}{void}\PYG{o}{*}\PYG{p}{)} \PYG{n}{data}\PYG{p}{();}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+cm}{/**}
\PYG{c+cm}{    * The width of the mask in Image pixels.}
\PYG{c+cm}{    * \PYGZbs{}include Mask\PYGZus{}width.txt}
\PYG{c+cm}{    * @since 2.2.6}
\PYG{c+cm}{    */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{int} \PYG{n+nf}{width}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{    * The height of the mask in Image pixels.}
\PYG{c+cm}{    * \PYGZbs{}include Mask\PYGZus{}height.txt}
\PYG{c+cm}{    * @since 2.2.6}
\PYG{c+cm}{    */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{int} \PYG{n+nf}{height}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{    * The offset of the mask from the left edge of the Image in pixels.}
\PYG{c+cm}{    * \PYGZbs{}include Mask\PYGZus{}offsetX.txt}
\PYG{c+cm}{    * @since 2.2.6}
\PYG{c+cm}{    */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{int} \PYG{n+nf}{offsetX}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{    * The offset of the mask from the top edge of the Image in pixels.}
\PYG{c+cm}{    * \PYGZbs{}include Mask\PYGZus{}offsetY.txt}
\PYG{c+cm}{    * @since 2.2.6}
\PYG{c+cm}{    */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{int} \PYG{n+nf}{offsetY}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{    * Reports whether this is a valid Mask object.}
\PYG{c+cm}{    * @since 2.2.6}
\PYG{c+cm}{    */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{n+nf}{isValid}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/** An invalid Mask object.}
\PYG{c+cm}{    * @since 2.2.6}
\PYG{c+cm}{    */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{static} \PYG{k}{const} \PYG{n}{Mask}\PYG{o}{\PYGZam{}} \PYG{n}{invalid}\PYG{p}{();}

    \PYG{c+cm}{/** Compares two Mask objects for equality.}
\PYG{c+cm}{    * @since 2.2.6}
\PYG{c+cm}{    */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{k}{operator}\PYG{o}{==}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Mask}\PYG{o}{\PYGZam{}}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/** Compares two Mask objects for inequality.}
\PYG{c+cm}{    * @since 2.2.6}
\PYG{c+cm}{    */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{k}{operator}\PYG{o}{!=}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Mask}\PYG{o}{\PYGZam{}}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/** Writes a brief, human readable description of the Mask object.}
\PYG{c+cm}{    * @since 2.2.6}
\PYG{c+cm}{    */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{friend} \PYG{n}{std}\PYG{o}{::}\PYG{n}{ostream}\PYG{o}{\PYGZam{}} \PYG{k}{operator}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{p}{(}\PYG{n}{std}\PYG{o}{::}\PYG{n}{ostream}\PYG{o}{\PYGZam{}}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Mask}\PYG{o}{\PYGZam{}}\PYG{p}{);}

    \PYG{n}{std}\PYG{o}{::}\PYG{n}{string} \PYG{n}{toString}\PYG{p}{()} \PYG{k}{const} \PYG{p}{\PYGZob{}}
      \PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{cstr} \PYG{o}{=} \PYG{n}{toCString}\PYG{p}{();}
      \PYG{n}{std}\PYG{o}{::}\PYG{n}{string} \PYG{n}{str}\PYG{p}{(}\PYG{n}{cstr}\PYG{p}{);}
      \PYG{n}{deleteCString}\PYG{p}{(}\PYG{n}{cstr}\PYG{p}{);}
      \PYG{k}{return} \PYG{n}{str}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

  \PYG{k}{private}\PYG{o}{:}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{toCString}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}
  \PYG{p}{\PYGZcb{};}

  \PYG{c+c1}{// For internal use only.}
  \PYG{k}{template}\PYG{o}{\PYGZlt{}}\PYG{k}{typename} \PYG{n}{L}\PYG{p}{,} \PYG{k}{typename} \PYG{n}{T}\PYG{o}{\PYGZgt{}}
  \PYG{k}{class} \PYG{n+nc}{ConstListIterator} \PYG{p}{\PYGZob{}}
  \PYG{k}{public}\PYG{o}{:}
    \PYG{n}{ConstListIterator}\PYG{o}{\PYGZlt{}}\PYG{n}{L}\PYG{p}{,}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{p}{()} \PYG{o}{:} \PYG{n}{m\PYGZus{}list}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{),} \PYG{n}{m\PYGZus{}index}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{p}{\PYGZob{}\PYGZcb{}}
    \PYG{n}{ConstListIterator}\PYG{o}{\PYGZlt{}}\PYG{n}{L}\PYG{p}{,}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{k}{const} \PYG{n}{L}\PYG{o}{\PYGZam{}} \PYG{n}{list}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{index}\PYG{p}{)} \PYG{o}{:} \PYG{n}{m\PYGZus{}list}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{list}\PYG{p}{),} \PYG{n}{m\PYGZus{}index}\PYG{p}{(}\PYG{n}{index}\PYG{p}{)} \PYG{p}{\PYGZob{}\PYGZcb{}}

    \PYG{k}{const} \PYG{n}{T} \PYG{k}{operator}\PYG{o}{*}\PYG{p}{()} \PYG{k}{const} \PYG{p}{\PYGZob{}} \PYG{k}{return} \PYG{p}{(}\PYG{o}{*}\PYG{n}{m\PYGZus{}list}\PYG{p}{)[}\PYG{n}{m\PYGZus{}index}\PYG{p}{];} \PYG{p}{\PYGZcb{}}
    \PYG{k}{const} \PYG{n}{ConstListIterator}\PYG{o}{\PYGZlt{}}\PYG{n}{L}\PYG{p}{,}\PYG{n}{T}\PYG{o}{\PYGZgt{}} \PYG{k}{operator}\PYG{o}{++}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{n}{ConstListIterator}\PYG{o}{\PYGZlt{}}\PYG{n}{L}\PYG{p}{,}\PYG{n}{T}\PYG{o}{\PYGZgt{}} \PYG{n}{ip}\PYG{p}{(}\PYG{o}{*}\PYG{k}{this}\PYG{p}{);} \PYG{o}{++}\PYG{n}{m\PYGZus{}index}\PYG{p}{;} \PYG{k}{return} \PYG{n}{ip}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
    \PYG{k}{const} \PYG{n}{ConstListIterator}\PYG{o}{\PYGZlt{}}\PYG{n}{L}\PYG{p}{,}\PYG{n}{T}\PYG{o}{\PYGZgt{}\PYGZam{}} \PYG{k}{operator}\PYG{o}{++}\PYG{p}{()} \PYG{p}{\PYGZob{}} \PYG{o}{++}\PYG{n}{m\PYGZus{}index}\PYG{p}{;} \PYG{k}{return} \PYG{o}{*}\PYG{k}{this}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
    \PYG{k+kt}{bool} \PYG{k}{operator}\PYG{o}{!=}\PYG{p}{(}\PYG{k}{const} \PYG{n}{ConstListIterator}\PYG{o}{\PYGZlt{}}\PYG{n}{L}\PYG{p}{,}\PYG{n}{T}\PYG{o}{\PYGZgt{}\PYGZam{}} \PYG{n}{rhs}\PYG{p}{)} \PYG{k}{const} \PYG{p}{\PYGZob{}} \PYG{k}{return} \PYG{n}{m\PYGZus{}index} \PYG{o}{!=} \PYG{n}{rhs}\PYG{p}{.}\PYG{n}{m\PYGZus{}index}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
    \PYG{k+kt}{bool} \PYG{k}{operator}\PYG{o}{==}\PYG{p}{(}\PYG{k}{const} \PYG{n}{ConstListIterator}\PYG{o}{\PYGZlt{}}\PYG{n}{L}\PYG{p}{,}\PYG{n}{T}\PYG{o}{\PYGZgt{}\PYGZam{}} \PYG{n}{rhs}\PYG{p}{)} \PYG{k}{const} \PYG{p}{\PYGZob{}} \PYG{k}{return} \PYG{n}{m\PYGZus{}index} \PYG{o}{==} \PYG{n}{rhs}\PYG{p}{.}\PYG{n}{m\PYGZus{}index}\PYG{p}{;} \PYG{p}{\PYGZcb{}}

    \PYG{k}{typedef} \PYG{n}{std}\PYG{o}{::}\PYG{k+kt}{ptrdiff\PYGZus{}t} \PYG{n}{difference\PYGZus{}type}\PYG{p}{;}
    \PYG{k}{typedef} \PYG{n}{T} \PYG{n}{value\PYGZus{}type}\PYG{p}{;}
    \PYG{k}{typedef} \PYG{k}{const} \PYG{n}{T}\PYG{o}{*} \PYG{n}{pointer}\PYG{p}{;}
    \PYG{k}{typedef} \PYG{k}{const} \PYG{n}{T}\PYG{o}{\PYGZam{}} \PYG{n}{reference}\PYG{p}{;}
    \PYG{k}{typedef} \PYG{n}{std}\PYG{o}{::}\PYG{n}{forward\PYGZus{}iterator\PYGZus{}tag} \PYG{n}{iterator\PYGZus{}category}\PYG{p}{;}

  \PYG{k}{private}\PYG{o}{:}
    \PYG{k}{const} \PYG{n}{L}\PYG{o}{*} \PYG{n}{m\PYGZus{}list}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{m\PYGZus{}index}\PYG{p}{;}
  \PYG{p}{\PYGZcb{};}

  \PYG{c+cm}{/**}
\PYG{c+cm}{   * The PointableList class represents a list of Pointable objects.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * Pointable objects include entities that can be pointed, such as fingers and tools.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * Get a PointableList object by calling Frame::pointables() or Hand::pointables().}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * \PYGZbs{}include PointableList\PYGZus{}PointableList.txt}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * @since 1.0}
\PYG{c+cm}{   */}
  \PYG{k}{class} \PYG{n+nc}{PointableList} \PYG{o}{:} \PYG{k}{public} \PYG{n}{Interface} \PYG{p}{\PYGZob{}}
  \PYG{k}{public}\PYG{o}{:}
    \PYG{c+c1}{// For internal use only.}
    \PYG{n}{PointableList}\PYG{p}{(}\PYG{k}{const} \PYG{n}{ListBaseImplementation}\PYG{o}{\PYGZlt{}}\PYG{n}{Pointable}\PYG{o}{\PYGZgt{}\PYGZam{}}\PYG{p}{);}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Constructs an empty list of pointable entities.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n+nf}{PointableList}\PYG{p}{();}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Returns the number of pointable entities in this list.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include PointableList\PYGZus{}count.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The number of pointable entities in this list.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{int} \PYG{n+nf}{count}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Reports whether the list is empty.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include PointableList\PYGZus{}isEmpty.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns True, if the list has no members.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{n+nf}{isEmpty}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Access a list member by its position in the list.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include PointableList\PYGZus{}operator\PYGZus{}index.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param index The zero\PYGZhy{}based list position index.}
\PYG{c+cm}{     * @returns The Pointable object at the specified index.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Pointable} \PYG{k}{operator}\PYG{p}{[](}\PYG{k+kt}{int} \PYG{n}{index}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Appends the members of the specified PointableList to this PointableList.}
\PYG{c+cm}{     * @param other A PointableList object containing Pointable objects}
\PYG{c+cm}{     * to append to the end of this PointableList.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{PointableList}\PYG{o}{\PYGZam{}} \PYG{n}{append}\PYG{p}{(}\PYG{k}{const} \PYG{n}{PointableList}\PYG{o}{\PYGZam{}} \PYG{n}{other}\PYG{p}{);}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Appends the members of the specified FingerList to this PointableList.}
\PYG{c+cm}{     * @param other A FingerList object containing Finger objects}
\PYG{c+cm}{     * to append to the end of this PointableList.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{PointableList}\PYG{o}{\PYGZam{}} \PYG{n}{append}\PYG{p}{(}\PYG{k}{const} \PYG{n}{FingerList}\PYG{o}{\PYGZam{}} \PYG{n}{other}\PYG{p}{);}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Appends the members of the specified ToolList to this PointableList.}
\PYG{c+cm}{     * @param other A ToolList object containing Tool objects}
\PYG{c+cm}{     * to append to the end of this PointableList.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{PointableList}\PYG{o}{\PYGZam{}} \PYG{n}{append}\PYG{p}{(}\PYG{k}{const} \PYG{n}{ToolList}\PYG{o}{\PYGZam{}} \PYG{n}{other}\PYG{p}{);}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The member of the list that is farthest to the left within the standard}
\PYG{c+cm}{     * Leap Motion frame of reference (i.e has the smallest X coordinate).}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include PointableList\PYGZus{}leftmost.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The leftmost pointable, or invalid if list is empty.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Pointable} \PYG{n+nf}{leftmost}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The member of the list that is farthest to the right within the standard}
\PYG{c+cm}{     * Leap Motion frame of reference (i.e has the largest X coordinate).}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include PointableList\PYGZus{}rightmost.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The rightmost pointable, or invalid if list is empty.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Pointable} \PYG{n+nf}{rightmost}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}


    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The member of the list that is farthest to the front within the standard}
\PYG{c+cm}{     * Leap Motion frame of reference (i.e has the smallest Z coordinate).}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include PointableList\PYGZus{}frontmost.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The frontmost pointable, or invalid if list is empty.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Pointable} \PYG{n+nf}{frontmost}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Returns a new list containing those members of the current list that are}
\PYG{c+cm}{     * extended. This includes all tools and any fingers whose isExtended() function is true.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The list of tools and extended fingers from the current list.}
\PYG{c+cm}{     * @since 2.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{PointableList} \PYG{n+nf}{extended}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * A C++ iterator type for PointableList objects.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include PointableList\PYGZus{}iterator.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{k}{typedef} \PYG{n}{ConstListIterator}\PYG{o}{\PYGZlt{}}\PYG{n}{PointableList}\PYG{p}{,} \PYG{n}{Pointable}\PYG{o}{\PYGZgt{}} \PYG{n}{const\PYGZus{}iterator}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The C++ iterator set to the beginning of this PointableList.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include PointableList\PYGZus{}begin.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{const\PYGZus{}iterator} \PYG{n+nf}{begin}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The C++ iterator set to the end of this PointableList.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include PointableList\PYGZus{}end.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{const\PYGZus{}iterator} \PYG{n+nf}{end}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}
  \PYG{p}{\PYGZcb{};}

  \PYG{c+cm}{/**}
\PYG{c+cm}{   * The FingerList class represents a list of Finger objects.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * Get a FingerList object by calling Frame::fingers().}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * \PYGZbs{}include FingerList\PYGZus{}FingerList.txt}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * @since 1.0}
\PYG{c+cm}{   */}
  \PYG{k}{class} \PYG{n+nc}{FingerList} \PYG{o}{:} \PYG{k}{public} \PYG{n}{Interface} \PYG{p}{\PYGZob{}}
  \PYG{k}{public}\PYG{o}{:}
    \PYG{c+c1}{// For internal use only.}
    \PYG{n}{FingerList}\PYG{p}{(}\PYG{k}{const} \PYG{n}{ListBaseImplementation}\PYG{o}{\PYGZlt{}}\PYG{n}{Finger}\PYG{o}{\PYGZgt{}\PYGZam{}}\PYG{p}{);}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Constructs an empty list of fingers.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n+nf}{FingerList}\PYG{p}{();}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Returns the number of fingers in this list.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include FingerList\PYGZus{}count.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The number of fingers in this list.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{int} \PYG{n+nf}{count}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Reports whether the list is empty.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include FingerList\PYGZus{}isEmpty.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns True, if the list has no members.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{n+nf}{isEmpty}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Access a list member by its position in the list.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include FingerList\PYGZus{}index.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param index The zero\PYGZhy{}based list position index.}
\PYG{c+cm}{     * @returns The Finger object at the specified index.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Finger} \PYG{k}{operator}\PYG{p}{[](}\PYG{k+kt}{int} \PYG{n}{index}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Appends the members of the specified FingerList to this FingerList.}
\PYG{c+cm}{     * @param other A FingerList object containing Finger objects}
\PYG{c+cm}{     * to append to the end of this FingerList.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{FingerList}\PYG{o}{\PYGZam{}} \PYG{n}{append}\PYG{p}{(}\PYG{k}{const} \PYG{n}{FingerList}\PYG{o}{\PYGZam{}} \PYG{n}{other}\PYG{p}{);}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The member of the list that is farthest to the left within the standard}
\PYG{c+cm}{     * Leap Motion frame of reference (i.e has the smallest X coordinate).}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include FingerList\PYGZus{}leftmost.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The leftmost finger, or invalid if list is empty.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Finger} \PYG{n+nf}{leftmost}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The member of the list that is farthest to the right within the standard}
\PYG{c+cm}{     * Leap Motion frame of reference (i.e has the largest X coordinate).}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include FingerList\PYGZus{}rightmost.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The rightmost finger, or invalid if list is empty.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Finger} \PYG{n+nf}{rightmost}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The member of the list that is farthest to the front within the standard}
\PYG{c+cm}{     * Leap Motion frame of reference (i.e has the smallest Z coordinate).}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include FingerList\PYGZus{}frontmost.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The frontmost finger, or invalid if list is empty.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Finger} \PYG{n+nf}{frontmost}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Returns a new list containing those fingers in the current list that are}
\PYG{c+cm}{     * extended.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include FingerList\PYGZus{}extended.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The list of extended fingers from the current list.}
\PYG{c+cm}{     * @since 2.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{FingerList} \PYG{n+nf}{extended}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Returns a list containing fingers from the current list of a given finger type by}
\PYG{c+cm}{     * modifying the existing list.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include FingerList\PYGZus{}fingerType.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{    * @returns The list of matching fingers from the current list.}
\PYG{c+cm}{     * @since 2.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{FingerList} \PYG{n+nf}{fingerType}\PYG{p}{(}\PYG{n}{Finger}\PYG{o}{::}\PYG{n}{Type} \PYG{n}{type}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * A C++ iterator type for FingerList objects.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include FingerList\PYGZus{}iterator.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{k}{typedef} \PYG{n}{ConstListIterator}\PYG{o}{\PYGZlt{}}\PYG{n}{FingerList}\PYG{p}{,} \PYG{n}{Finger}\PYG{o}{\PYGZgt{}} \PYG{n}{const\PYGZus{}iterator}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The C++ iterator set to the beginning of this FingerList.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include FingerList\PYGZus{}begin.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{const\PYGZus{}iterator} \PYG{n+nf}{begin}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The C++ iterator set to the end of this FingerList.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include FingerList\PYGZus{}end.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{const\PYGZus{}iterator} \PYG{n+nf}{end}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}
  \PYG{p}{\PYGZcb{};}

  \PYG{c+cm}{/**}
\PYG{c+cm}{   * The ToolList class represents a list of Tool objects.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * Get a ToolList object by calling Frame::tools().}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * \PYGZbs{}include ToolList\PYGZus{}ToolList.txt}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * @since 1.0}
\PYG{c+cm}{   */}
  \PYG{k}{class} \PYG{n+nc}{ToolList} \PYG{o}{:} \PYG{k}{public} \PYG{n}{Interface} \PYG{p}{\PYGZob{}}
  \PYG{k}{public}\PYG{o}{:}
    \PYG{c+c1}{// For internal use only.}
    \PYG{n}{ToolList}\PYG{p}{(}\PYG{k}{const} \PYG{n}{ListBaseImplementation}\PYG{o}{\PYGZlt{}}\PYG{n}{Tool}\PYG{o}{\PYGZgt{}\PYGZam{}}\PYG{p}{);}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Constructs an empty list of tools.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n+nf}{ToolList}\PYG{p}{();}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Returns the number of tools in this list.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include ToolList\PYGZus{}count.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The number of tools in this list.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{int} \PYG{n+nf}{count}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Reports whether the list is empty.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include ToolList\PYGZus{}isEmpty.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns True, if the list has no members.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{n+nf}{isEmpty}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Access a list member by its position in the list.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include ToolList\PYGZus{}operator\PYGZus{}index.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param index The zero\PYGZhy{}based list position index.}
\PYG{c+cm}{     * @returns The Tool object at the specified index.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Tool} \PYG{k}{operator}\PYG{p}{[](}\PYG{k+kt}{int} \PYG{n}{index}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Appends the members of the specified ToolList to this ToolList.}
\PYG{c+cm}{     * @param other A ToolList object containing Tool objects}
\PYG{c+cm}{     * to append to the end of this ToolList.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{ToolList}\PYG{o}{\PYGZam{}} \PYG{n}{append}\PYG{p}{(}\PYG{k}{const} \PYG{n}{ToolList}\PYG{o}{\PYGZam{}} \PYG{n}{other}\PYG{p}{);}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The member of the list that is farthest to the left within the standard}
\PYG{c+cm}{     * Leap Motion frame of reference (i.e has the smallest X coordinate).}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include ToolList\PYGZus{}leftmost.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The leftmost tool, or invalid if list is empty.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Tool} \PYG{n+nf}{leftmost}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The member of the list that is farthest to the right within the standard}
\PYG{c+cm}{     * Leap Motion frame of reference (i.e has the largest X coordinate).}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include ToolList\PYGZus{}rightmost.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The rightmost tool, or invalid if list is empty.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Tool} \PYG{n+nf}{rightmost}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The member of the list that is farthest to the front within the standard}
\PYG{c+cm}{     * Leap Motion frame of reference (i.e has the smallest Z coordinate).}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include ToolList\PYGZus{}frontmost.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The frontmost tool, or invalid if list is empty.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Tool} \PYG{n+nf}{frontmost}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * A C++ iterator type for ToolList objects.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include ToolList\PYGZus{}iterator.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{k}{typedef} \PYG{n}{ConstListIterator}\PYG{o}{\PYGZlt{}}\PYG{n}{ToolList}\PYG{p}{,} \PYG{n}{Tool}\PYG{o}{\PYGZgt{}} \PYG{n}{const\PYGZus{}iterator}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The C++ iterator set to the beginning of this ToolList.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include ToolList\PYGZus{}begin.txt}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{const\PYGZus{}iterator} \PYG{n+nf}{begin}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The C++ iterator set to the end of this ToolList.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include ToolList\PYGZus{}end.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{const\PYGZus{}iterator} \PYG{n+nf}{end}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}
  \PYG{p}{\PYGZcb{};}

  \PYG{c+cm}{/**}
\PYG{c+cm}{   * The HandList class represents a list of Hand objects.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * Get a HandList object by calling Frame::hands().}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * \PYGZbs{}include HandList\PYGZus{}HandList.txt}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * @since 1.0}
\PYG{c+cm}{   */}
  \PYG{k}{class} \PYG{n+nc}{HandList} \PYG{o}{:} \PYG{k}{public} \PYG{n}{Interface} \PYG{p}{\PYGZob{}}
  \PYG{k}{public}\PYG{o}{:}
    \PYG{c+c1}{// For internal use only.}
    \PYG{n}{HandList}\PYG{p}{(}\PYG{k}{const} \PYG{n}{ListBaseImplementation}\PYG{o}{\PYGZlt{}}\PYG{n}{Hand}\PYG{o}{\PYGZgt{}\PYGZam{}}\PYG{p}{);}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Constructs an empty list of hands.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n+nf}{HandList}\PYG{p}{();}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Returns the number of hands in this list.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include HandList\PYGZus{}count.txt}
\PYG{c+cm}{     * @returns The number of hands in this list.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{int} \PYG{n+nf}{count}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Reports whether the list is empty.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include HandList\PYGZus{}isEmpty.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns True, if the list has no members.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{n+nf}{isEmpty}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Access a list member by its position in the list.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include HandList\PYGZus{}operator\PYGZus{}index.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param index The zero\PYGZhy{}based list position index.}
\PYG{c+cm}{     * @returns The Hand object at the specified index.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Hand} \PYG{k}{operator}\PYG{p}{[](}\PYG{k+kt}{int} \PYG{n}{index}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Appends the members of the specified HandList to this HandList.}
\PYG{c+cm}{     * @param other A HandList object containing Hand objects}
\PYG{c+cm}{     * to append to the end of this HandList.}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{HandList}\PYG{o}{\PYGZam{}} \PYG{n}{append}\PYG{p}{(}\PYG{k}{const} \PYG{n}{HandList}\PYG{o}{\PYGZam{}} \PYG{n}{other}\PYG{p}{);}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The member of the list that is farthest to the left within the standard}
\PYG{c+cm}{     * Leap Motion frame of reference (i.e has the smallest X coordinate).}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Note: to determine whether a hand is the left hand, use the Hand::isLeft() function.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include HandList\PYGZus{}leftmost.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The leftmost hand, or invalid if list is empty.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Hand} \PYG{n+nf}{leftmost}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The member of the list that is farthest to the right within the standard}
\PYG{c+cm}{     * Leap Motion frame of reference (i.e has the largest X coordinate).}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Note: to determine whether a hand is the right hand, use the Hand::isRight() function.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include HandList\PYGZus{}rightmost.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The rightmost hand, or invalid if list is empty.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Hand} \PYG{n+nf}{rightmost}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The member of the list that is farthest to the front within the standard}
\PYG{c+cm}{     * Leap Motion frame of reference (i.e has the smallest Z coordinate).}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include HandList\PYGZus{}frontmost.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The frontmost hand, or invalid if list is empty.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Hand} \PYG{n+nf}{frontmost}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * A C++ iterator type for this HandList objects.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include HandList\PYGZus{}iterator.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{k}{typedef} \PYG{n}{ConstListIterator}\PYG{o}{\PYGZlt{}}\PYG{n}{HandList}\PYG{p}{,} \PYG{n}{Hand}\PYG{o}{\PYGZgt{}} \PYG{n}{const\PYGZus{}iterator}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The C++ iterator set to the beginning of this HandList.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include HandList\PYGZus{}begin.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{const\PYGZus{}iterator} \PYG{n+nf}{begin}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The C++ iterator set to the end of this HandList.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include HandList\PYGZus{}end.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{const\PYGZus{}iterator} \PYG{n+nf}{end}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}
  \PYG{p}{\PYGZcb{};}

  \PYG{c+cm}{/**}
\PYG{c+cm}{   * The GestureList class represents a list of Gesture objects.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * Get a GestureList object from a Frame object.}
\PYG{c+cm}{   * @since 1.0}
\PYG{c+cm}{   */}
  \PYG{k}{class} \PYG{n+nc}{GestureList} \PYG{o}{:} \PYG{k}{public} \PYG{n}{Interface} \PYG{p}{\PYGZob{}}
  \PYG{k}{public}\PYG{o}{:}
    \PYG{c+c1}{// For internal use only.}
    \PYG{n}{GestureList}\PYG{p}{(}\PYG{k}{const} \PYG{n}{ListBaseImplementation}\PYG{o}{\PYGZlt{}}\PYG{n}{Gesture}\PYG{o}{\PYGZgt{}\PYGZam{}}\PYG{p}{);}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Constructs an empty gesture list.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n+nf}{GestureList}\PYG{p}{();}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The length of this list.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include GestureList\PYGZus{}count.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The number of gestures in this list.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{int} \PYG{n+nf}{count}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Reports whether the list is empty.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include GestureList\PYGZus{}isEmpty.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns True, if the list has no members.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{n+nf}{isEmpty}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Access a list member by its position in the list.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include GestureList\PYGZus{}operator\PYGZus{}index.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param index The zero\PYGZhy{}based list position index.}
\PYG{c+cm}{     * @returns The Gesture object at the specified index.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Gesture} \PYG{k}{operator}\PYG{p}{[](}\PYG{k+kt}{int} \PYG{n}{index}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Appends the members of the specified GestureList to this GestureList.}
\PYG{c+cm}{     * @param other A GestureList object containing Gesture objects}
\PYG{c+cm}{     * to append to the end of this GestureList.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{GestureList}\PYG{o}{\PYGZam{}} \PYG{n}{append}\PYG{p}{(}\PYG{k}{const} \PYG{n}{GestureList}\PYG{o}{\PYGZam{}} \PYG{n}{other}\PYG{p}{);}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * A C++ iterator type for GestureList objects.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include GestureList\PYGZus{}iterator.txt}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{k}{typedef} \PYG{n}{ConstListIterator}\PYG{o}{\PYGZlt{}}\PYG{n}{GestureList}\PYG{p}{,} \PYG{n}{Gesture}\PYG{o}{\PYGZgt{}} \PYG{n}{const\PYGZus{}iterator}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The C++ iterator set to the beginning of this GestureList.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include GestureList\PYGZus{}begin.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{const\PYGZus{}iterator} \PYG{n+nf}{begin}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The C++ iterator set to the end of this GestureList.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include GestureList\PYGZus{}end.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{const\PYGZus{}iterator} \PYG{n+nf}{end}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}
  \PYG{p}{\PYGZcb{};}

  \PYG{c+cm}{/*}
\PYG{c+cm}{   * Deprecated as of version 1.2.}
\PYG{c+cm}{   */}
  \PYG{k}{class} \PYG{n+nc}{ScreenList} \PYG{o}{:} \PYG{k}{public} \PYG{n}{Interface} \PYG{p}{\PYGZob{}}
  \PYG{k}{public}\PYG{o}{:}
    \PYG{c+c1}{// For internal use only.}
    \PYG{n}{ScreenList}\PYG{p}{(}\PYG{k}{const} \PYG{n}{ListBaseImplementation}\PYG{o}{\PYGZlt{}}\PYG{n}{Screen}\PYG{o}{\PYGZgt{}\PYGZam{}}\PYG{p}{);}

    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n+nf}{ScreenList}\PYG{p}{();}

    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{int} \PYG{n+nf}{count}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{n+nf}{isEmpty}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Screen} \PYG{k}{operator}\PYG{p}{[](}\PYG{k+kt}{int} \PYG{n}{index}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{k}{typedef} \PYG{n}{ConstListIterator}\PYG{o}{\PYGZlt{}}\PYG{n}{ScreenList}\PYG{p}{,} \PYG{n}{Screen}\PYG{o}{\PYGZgt{}} \PYG{n}{const\PYGZus{}iterator}\PYG{p}{;}

    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{const\PYGZus{}iterator} \PYG{n+nf}{begin}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{const\PYGZus{}iterator} \PYG{n+nf}{end}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Screen} \PYG{n+nf}{closestScreenHit}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Pointable}\PYG{o}{\PYGZam{}} \PYG{n}{pointable}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Screen} \PYG{n+nf}{closestScreenHit}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZam{}} \PYG{n}{position}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZam{}} \PYG{n}{direction}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Screen} \PYG{n+nf}{closestScreen}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZam{}} \PYG{n}{position}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}
  \PYG{p}{\PYGZcb{};}

  \PYG{c+cm}{/**}
\PYG{c+cm}{   * The DeviceList class represents a list of Device objects.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * Get a DeviceList object by calling Controller::devices().}
\PYG{c+cm}{   * @since 1.0}
\PYG{c+cm}{   */}
  \PYG{k}{class} \PYG{n+nc}{DeviceList} \PYG{o}{:} \PYG{k}{public} \PYG{n}{Interface} \PYG{p}{\PYGZob{}}
  \PYG{k}{public}\PYG{o}{:}
    \PYG{c+c1}{// For internal use only.}
    \PYG{n}{DeviceList}\PYG{p}{(}\PYG{k}{const} \PYG{n}{ListBaseImplementation}\PYG{o}{\PYGZlt{}}\PYG{n}{Device}\PYG{o}{\PYGZgt{}\PYGZam{}}\PYG{p}{);}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Constructs an empty list of devices.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n+nf}{DeviceList}\PYG{p}{();}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Returns the number of devices in this list.}
\PYG{c+cm}{     * @returns The number of devices in this list.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{int} \PYG{n+nf}{count}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Reports whether the list is empty.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include DeviceList\PYGZus{}isEmpty.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns True, if the list has no members.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{n+nf}{isEmpty}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Access a list member by its position in the list.}
\PYG{c+cm}{     * @param index The zero\PYGZhy{}based list position index.}
\PYG{c+cm}{     * @returns The Device object at the specified index.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Device} \PYG{k}{operator}\PYG{p}{[](}\PYG{k+kt}{int} \PYG{n}{index}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Appends the members of the specified DeviceList to this DeviceList.}
\PYG{c+cm}{     * @param other A DeviceList object containing Device objects}
\PYG{c+cm}{     * to append to the end of this DeviceList.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{DeviceList}\PYG{o}{\PYGZam{}} \PYG{n}{append}\PYG{p}{(}\PYG{k}{const} \PYG{n}{DeviceList}\PYG{o}{\PYGZam{}} \PYG{n}{other}\PYG{p}{);}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * A C++ iterator type for this DeviceList objects.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{k}{typedef} \PYG{n}{ConstListIterator}\PYG{o}{\PYGZlt{}}\PYG{n}{DeviceList}\PYG{p}{,} \PYG{n}{Device}\PYG{o}{\PYGZgt{}} \PYG{n}{const\PYGZus{}iterator}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The C++ iterator set to the beginning of this DeviceList.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{const\PYGZus{}iterator} \PYG{n+nf}{begin}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The C++ iterator set to the end of this DeviceList.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{const\PYGZus{}iterator} \PYG{n+nf}{end}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}
  \PYG{p}{\PYGZcb{};}

  \PYG{c+cm}{/**}
\PYG{c+cm}{   * The ImageList class represents a list of Image objects.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * Get the ImageList object associated with the a Frame of tracking data}
\PYG{c+cm}{   * by calling Frame::images(). Get the most recent set of images, which can be}
\PYG{c+cm}{   * newer than the images used to create the current frame, by calling}
\PYG{c+cm}{   * Controller::images().}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * @since 2.1.0}
\PYG{c+cm}{   */}
  \PYG{k}{class} \PYG{n+nc}{ImageList} \PYG{o}{:} \PYG{k}{public} \PYG{n}{Interface} \PYG{p}{\PYGZob{}}
  \PYG{k}{public}\PYG{o}{:}
    \PYG{c+c1}{// For internal use only.}
    \PYG{n}{ImageList}\PYG{p}{(}\PYG{k}{const} \PYG{n}{ListBaseImplementation}\PYG{o}{\PYGZlt{}}\PYG{n}{Image}\PYG{o}{\PYGZgt{}\PYGZam{}}\PYG{p}{);}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Constructs an empty list of images.}
\PYG{c+cm}{     * @since 2.1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n+nf}{ImageList}\PYG{p}{();}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The number of images in this list.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The number of images in this list.}
\PYG{c+cm}{     * @since 2.1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{int} \PYG{n+nf}{count}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Reports whether the list is empty.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include ImageList\PYGZus{}isEmpty.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns True, if the list has no members.}
\PYG{c+cm}{     * @since 2.1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{n+nf}{isEmpty}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Access a list member by its position in the list.}
\PYG{c+cm}{     * @param index The zero\PYGZhy{}based list position index.}
\PYG{c+cm}{     * @returns The Image object at the specified index.}
\PYG{c+cm}{     * @since 2.1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Image} \PYG{k}{operator}\PYG{p}{[](}\PYG{k+kt}{int} \PYG{n}{index}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Appends the members of the specified ImageList to this ImageList.}
\PYG{c+cm}{     * @param other A ImageList object containing Image objects}
\PYG{c+cm}{     * to append to the end of this ImageList.}
\PYG{c+cm}{     * @since 2.1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{ImageList}\PYG{o}{\PYGZam{}} \PYG{n}{append}\PYG{p}{(}\PYG{k}{const} \PYG{n}{ImageList}\PYG{o}{\PYGZam{}} \PYG{n}{other}\PYG{p}{);}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * A C++ iterator type for this ImageList objects.}
\PYG{c+cm}{     * @since 2.1.0}
\PYG{c+cm}{     */}
    \PYG{k}{typedef} \PYG{n}{ConstListIterator}\PYG{o}{\PYGZlt{}}\PYG{n}{ImageList}\PYG{p}{,} \PYG{n}{Image}\PYG{o}{\PYGZgt{}} \PYG{n}{const\PYGZus{}iterator}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The C++ iterator set to the beginning of this ImageList.}
\PYG{c+cm}{     * @since 2.1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{const\PYGZus{}iterator} \PYG{n+nf}{begin}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The C++ iterator set to the end of this ImageList.}
\PYG{c+cm}{     * @since 2.1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{const\PYGZus{}iterator} \PYG{n+nf}{end}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}
  \PYG{p}{\PYGZcb{};}

  \PYG{c+cm}{/**}
\PYG{c+cm}{  * Note: This class is an experimental API for internal use only. It may be}
\PYG{c+cm}{  * removed without warning.}
\PYG{c+cm}{  *}
\PYG{c+cm}{  * Represents a quad\PYGZhy{}like object tracked by the Leap Motion sensors.}
\PYG{c+cm}{  *}
\PYG{c+cm}{  * Only one quad can be tracked. Once a supported quad is tracked, the state}
\PYG{c+cm}{  * of that quad will be updated for each frame of Leap Motion tracking data.}
\PYG{c+cm}{  *}
\PYG{c+cm}{  * A TrackedQuad object represents the state of the quad at one moment in time.}
\PYG{c+cm}{  * Get a new object from subsequent frames to get the latest state information.}
\PYG{c+cm}{  * @since 2.2.6}
\PYG{c+cm}{  */}
  \PYG{k}{class} \PYG{n+nc}{TrackedQuad} \PYG{o}{:} \PYG{k}{public} \PYG{n}{Interface} \PYG{p}{\PYGZob{}}
  \PYG{k}{public}\PYG{o}{:}

    \PYG{c+c1}{// For internal use only.}
    \PYG{n}{TrackedQuad}\PYG{p}{(}\PYG{n}{TrackedQuadImplementation}\PYG{o}{*}\PYG{p}{);}

    \PYG{c+cm}{/**}
\PYG{c+cm}{    * Constructs a new TrackedQuad object. Do not use. Get valid TrackedQuads}
\PYG{c+cm}{    * from a Controller or Frame object.}
\PYG{c+cm}{    * \PYGZbs{}include TrackedQuad\PYGZus{}constructor\PYGZus{}controller.txt}
\PYG{c+cm}{    * \PYGZbs{}include TrackedQuad\PYGZus{}constructor\PYGZus{}frame.txt}
\PYG{c+cm}{    * @since 2.2.6}
\PYG{c+cm}{    */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n+nf}{TrackedQuad}\PYG{p}{();}

    \PYG{c+cm}{/**}
\PYG{c+cm}{    * The physical width of the quad display area in millimeters.}
\PYG{c+cm}{    * \PYGZbs{}include TrackedQuad\PYGZus{}width.txt}
\PYG{c+cm}{    * @since 2.2.6}
\PYG{c+cm}{    */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{float} \PYG{n+nf}{width}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{    * The physical height of the quad display area in millimeters.}
\PYG{c+cm}{    * \PYGZbs{}include TrackedQuad\PYGZus{}height.txt}
\PYG{c+cm}{    * @since 2.2.6}
\PYG{c+cm}{    */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{float} \PYG{n+nf}{height}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{    * The horizontal resolution of the quad display area in pixels.}
\PYG{c+cm}{    * This value is set in a configuration file. It is not determined dynamically.}
\PYG{c+cm}{    * \PYGZbs{}include TrackedQuad\PYGZus{}resolutionX.txt}
\PYG{c+cm}{    * @since 2.2.6}
\PYG{c+cm}{    */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{int} \PYG{n+nf}{resolutionX}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{    * The vertical resolution of the quad display area in pixels.}
\PYG{c+cm}{    * This value is set in a configuration file. It is not determined dynamically.}
\PYG{c+cm}{    * \PYGZbs{}include TrackedQuad\PYGZus{}resolutionY.txt}
\PYG{c+cm}{    * @since 2.2.6}
\PYG{c+cm}{    */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{int} \PYG{n+nf}{resolutionY}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{    * Reports whether the quad is currently detected within the Leap Motion}
\PYG{c+cm}{    * field of view.}
\PYG{c+cm}{    * \PYGZbs{}include TrackedQuad\PYGZus{}visible.txt}
\PYG{c+cm}{    * @since 2.2.6}
\PYG{c+cm}{    */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{n+nf}{visible}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{    * The orientation of the quad within the Leap Motion frame of reference.}
\PYG{c+cm}{    * \PYGZbs{}include TrackedQuad\PYGZus{}orientation.txt}
\PYG{c+cm}{    * @since 2.2.6}
\PYG{c+cm}{    */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Matrix} \PYG{n+nf}{orientation}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{    * The position of the center of the quad display area within the Leap}
\PYG{c+cm}{    * Motion frame of reference. In millimeters.}
\PYG{c+cm}{    * \PYGZbs{}include TrackedQuad\PYGZus{}position.txt}
\PYG{c+cm}{    * @since 2.2.6}
\PYG{c+cm}{    */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Vector} \PYG{n+nf}{position}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{    * The list of masks for the current set of images. A mask is a bitmap}
\PYG{c+cm}{    * indicating which pixels in the image contain fingers or part of the hand}
\PYG{c+cm}{    * in front of the quad.}
\PYG{c+cm}{    *}
\PYG{c+cm}{    * The mask at index 0 corresponds to the left image; that with index 1, to}
\PYG{c+cm}{    * the right image.}
\PYG{c+cm}{    * \PYGZbs{}include TrackedQuad\PYGZus{}masks.txt}
\PYG{c+cm}{    * @since 2.2.6}
\PYG{c+cm}{    */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{MaskList} \PYG{n+nf}{masks}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{    * The images from which the state of this TrackedQuad was derived.}
\PYG{c+cm}{    * These are the same image objects that you can get from the Controller}
\PYG{c+cm}{    * or Frame object from which you got this TrackedQuad.}
\PYG{c+cm}{    * \PYGZbs{}include TrackedQuad\PYGZus{}images.txt}
\PYG{c+cm}{    * @since 2.2.6}
\PYG{c+cm}{    */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{ImageList} \PYG{n+nf}{images}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{    * Reports whether this is a valid object.}
\PYG{c+cm}{    * \PYGZbs{}include TrackedQuad\PYGZus{}isValid.txt}
\PYG{c+cm}{    * @since 2.2.6}
\PYG{c+cm}{    */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{n+nf}{isValid}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{    * An invalid object.}
\PYG{c+cm}{    * @since 2.2.6}
\PYG{c+cm}{    */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{static} \PYG{k}{const} \PYG{n}{TrackedQuad}\PYG{o}{\PYGZam{}} \PYG{n}{invalid}\PYG{p}{();}

    \PYG{c+cm}{/**}
\PYG{c+cm}{    * Compares quad objects for equality.}
\PYG{c+cm}{    * @since 2.2.6}
\PYG{c+cm}{    */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{k}{operator}\PYG{o}{==}\PYG{p}{(}\PYG{k}{const} \PYG{n}{TrackedQuad}\PYG{o}{\PYGZam{}}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{    * Compares quad objects for inequality.}
\PYG{c+cm}{    * @since 2.2.6}
\PYG{c+cm}{    */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{k}{operator}\PYG{o}{!=}\PYG{p}{(}\PYG{k}{const} \PYG{n}{TrackedQuad}\PYG{o}{\PYGZam{}}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{    * Provides a brief, human\PYGZhy{}readable description of this quad.}
\PYG{c+cm}{    * @since 2.2.6}
\PYG{c+cm}{    */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{friend} \PYG{n}{std}\PYG{o}{::}\PYG{n}{ostream}\PYG{o}{\PYGZam{}} \PYG{k}{operator}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{p}{(}\PYG{n}{std}\PYG{o}{::}\PYG{n}{ostream}\PYG{o}{\PYGZam{}}\PYG{p}{,} \PYG{k}{const} \PYG{n}{TrackedQuad}\PYG{o}{\PYGZam{}}\PYG{p}{);}

    \PYG{n}{std}\PYG{o}{::}\PYG{n}{string} \PYG{n}{toString}\PYG{p}{()} \PYG{k}{const} \PYG{p}{\PYGZob{}}
      \PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{cstr} \PYG{o}{=} \PYG{n}{toCString}\PYG{p}{();}
      \PYG{n}{std}\PYG{o}{::}\PYG{n}{string} \PYG{n}{str}\PYG{p}{(}\PYG{n}{cstr}\PYG{p}{);}
      \PYG{n}{deleteCString}\PYG{p}{(}\PYG{n}{cstr}\PYG{p}{);}
      \PYG{k}{return} \PYG{n}{str}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

  \PYG{k}{private}\PYG{o}{:}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{toCString}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}
  \PYG{p}{\PYGZcb{};}

  \PYG{c+cm}{/**}
\PYG{c+cm}{  * Note: This class is an experimental API for internal use only. It may be}
\PYG{c+cm}{  * removed without warning.}
\PYG{c+cm}{  *}
\PYG{c+cm}{  * A list containing Mask objects.}
\PYG{c+cm}{  * @since 2.2.6}
\PYG{c+cm}{  */}
  \PYG{k}{class} \PYG{n+nc}{MaskList} \PYG{o}{:} \PYG{k}{public} \PYG{n}{Interface} \PYG{p}{\PYGZob{}}
  \PYG{k}{public}\PYG{o}{:}
    \PYG{c+c1}{// For internal use only.}
    \PYG{n}{MaskList}\PYG{p}{(}\PYG{k}{const} \PYG{n}{ListBaseImplementation}\PYG{o}{\PYGZlt{}}\PYG{n}{Mask}\PYG{o}{\PYGZgt{}\PYGZam{}}\PYG{p}{);}

    \PYG{c+cm}{/**}
\PYG{c+cm}{    * Constructs an empty list for Mask objects.}
\PYG{c+cm}{    * @since 2.2.6}
\PYG{c+cm}{    */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n+nf}{MaskList}\PYG{p}{();}

    \PYG{c+cm}{/**}
\PYG{c+cm}{    * The number of masks in this list.}
\PYG{c+cm}{    * @since 2.2.6}
\PYG{c+cm}{    */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{int} \PYG{n+nf}{count}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{    * Reports whether this list is empty.}
\PYG{c+cm}{    * @since 2.2.6}
\PYG{c+cm}{    */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{n+nf}{isEmpty}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{    * The MaskList supports array indexing.}
\PYG{c+cm}{    * @since 2.2.6}
\PYG{c+cm}{    */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Mask} \PYG{k}{operator}\PYG{p}{[](}\PYG{k+kt}{int} \PYG{n}{index}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{    * Appends the contents of another list of masks to this one.}
\PYG{c+cm}{    * @since 2.2.6}
\PYG{c+cm}{    */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{MaskList}\PYG{o}{\PYGZam{}} \PYG{n}{append}\PYG{p}{(}\PYG{k}{const} \PYG{n}{MaskList}\PYG{o}{\PYGZam{}} \PYG{n}{other}\PYG{p}{);}

    \PYG{k}{typedef} \PYG{n}{ConstListIterator}\PYG{o}{\PYGZlt{}}\PYG{n}{MaskList}\PYG{p}{,} \PYG{n}{Mask}\PYG{o}{\PYGZgt{}} \PYG{n}{const\PYGZus{}iterator}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{    * A list iterator set to the beginning of the list.}
\PYG{c+cm}{    * @since 2.2.6}
\PYG{c+cm}{    */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{const\PYGZus{}iterator} \PYG{n+nf}{begin}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{    * A list iterator set to the end of the list.}
\PYG{c+cm}{    * @since 2.2.6}
\PYG{c+cm}{    */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{const\PYGZus{}iterator} \PYG{n+nf}{end}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}
  \PYG{p}{\PYGZcb{};}

  \PYG{c+cm}{/**}
\PYG{c+cm}{   * The InteractionBox class represents a box\PYGZhy{}shaped region completely}
\PYG{c+cm}{   * within the field of view of the Leap Motion controller.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * The interaction box is an axis\PYGZhy{}aligned rectangular prism and provides normalized}
\PYG{c+cm}{   * coordinates for hands, fingers, and tools within this box. The InteractionBox class}
\PYG{c+cm}{   * can make it easier to map positions in the Leap Motion coordinate system to 2D or}
\PYG{c+cm}{   * 3D coordinate systems used for application drawing.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * \PYGZbs{}image html images/Leap\PYGZus{}InteractionBox.png}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * The InteractionBox region is defined by a center and dimensions along the x, y,}
\PYG{c+cm}{   * and z axes.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * Get an InteractionBox object from a Frame object.}
\PYG{c+cm}{   * @since 1.0}
\PYG{c+cm}{   */}
  \PYG{k}{class} \PYG{n+nc}{InteractionBox} \PYG{o}{:} \PYG{k}{public} \PYG{n}{Interface} \PYG{p}{\PYGZob{}}
  \PYG{k}{public}\PYG{o}{:}
    \PYG{c+c1}{// For internal use only.}
    \PYG{n}{InteractionBox}\PYG{p}{(}\PYG{n}{InteractionBoxImplementation}\PYG{o}{*}\PYG{p}{);}

    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n+nf}{InteractionBox}\PYG{p}{();}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Normalizes the coordinates of a point using the interaction box.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include InteractionBox\PYGZus{}normalizePoint.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Coordinates from the Leap Motion frame of reference (millimeters) are converted}
\PYG{c+cm}{     * to a range of [0..1] such that the minimum value of the InteractionBox maps to 0}
\PYG{c+cm}{     * and the maximum value of the InteractionBox maps to 1.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param position The input position in device coordinates.}
\PYG{c+cm}{     * @param clamp Whether or not to limit the output value to the range [0,1] when the}
\PYG{c+cm}{     * input position is outside the InteractionBox. Defaults to true.}
\PYG{c+cm}{     * @returns The normalized position.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Vector} \PYG{n+nf}{normalizePoint}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZam{}} \PYG{n}{position}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{n}{clamp} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Converts a position defined by normalized InteractionBox coordinates into device}
\PYG{c+cm}{     * coordinates in millimeters.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include InteractionBox\PYGZus{}denormalizePoint.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * This function performs the inverse of normalizePoint().}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param normalizedPosition The input position in InteractionBox coordinates.}
\PYG{c+cm}{     * @returns The corresponding denormalized position in device coordinates.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Vector} \PYG{n+nf}{denormalizePoint}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZam{}} \PYG{n}{normalizedPosition}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The center of the InteractionBox in device coordinates (millimeters). This point}
\PYG{c+cm}{     * is equidistant from all sides of the box.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include InteractionBox\PYGZus{}center.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The InteractionBox center in device coordinates.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Vector} \PYG{n+nf}{center}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The width of the InteractionBox in millimeters, measured along the x\PYGZhy{}axis.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include InteractionBox\PYGZus{}width.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The InteractionBox width in millimeters.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{float} \PYG{n+nf}{width}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The height of the InteractionBox in millimeters, measured along the y\PYGZhy{}axis.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include InteractionBox\PYGZus{}height.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The InteractionBox height in millimeters.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{float} \PYG{n+nf}{height}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The depth of the InteractionBox in millimeters, measured along the z\PYGZhy{}axis.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include InteractionBox\PYGZus{}depth.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The InteractionBox depth in millimeters.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{float} \PYG{n+nf}{depth}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Reports whether this is a valid InteractionBox object.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include InteractionBox\PYGZus{}isValid.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns True, if this InteractionBox object contains valid data.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{n+nf}{isValid}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Returns an invalid InteractionBox object.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * You can use the instance returned by this function in comparisons testing}
\PYG{c+cm}{     * whether a given InteractionBox instance is valid or invalid. (You can also use the}
\PYG{c+cm}{     * InteractionBox::isValid() function.)}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include InteractionBox\PYGZus{}invalid.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The invalid InteractionBox instance.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{static} \PYG{k}{const} \PYG{n}{InteractionBox}\PYG{o}{\PYGZam{}} \PYG{n}{invalid}\PYG{p}{();}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Compare InteractionBox object equality.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include InteractionBox\PYGZus{}operator\PYGZus{}equals.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Two InteractionBox objects are equal if and only if both InteractionBox objects represent the}
\PYG{c+cm}{     * exact same InteractionBox and both InteractionBoxes are valid.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{k}{operator}\PYG{o}{==}\PYG{p}{(}\PYG{k}{const} \PYG{n}{InteractionBox}\PYG{o}{\PYGZam{}}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Compare InteractionBox object inequality.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include InteractionBox\PYGZus{}operator\PYGZus{}not\PYGZus{}equals.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Two InteractionBox objects are equal if and only if both InteractionBox objects represent the}
\PYG{c+cm}{     * exact same InteractionBox and both InteractionBoxes are valid.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{k}{operator}\PYG{o}{!=}\PYG{p}{(}\PYG{k}{const} \PYG{n}{InteractionBox}\PYG{o}{\PYGZam{}}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Writes a brief, human readable description of the InteractionBox object.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include InteractionBox\PYGZus{}operator\PYGZus{}stream.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{friend} \PYG{n}{std}\PYG{o}{::}\PYG{n}{ostream}\PYG{o}{\PYGZam{}} \PYG{k}{operator}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{p}{(}\PYG{n}{std}\PYG{o}{::}\PYG{n}{ostream}\PYG{o}{\PYGZam{}}\PYG{p}{,} \PYG{k}{const} \PYG{n}{InteractionBox}\PYG{o}{\PYGZam{}}\PYG{p}{);}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * A string containing a brief, human readable description of the InteractionBox object.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns A description of the InteractionBox as a string.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{std}\PYG{o}{::}\PYG{n}{string} \PYG{n}{toString}\PYG{p}{()} \PYG{k}{const} \PYG{p}{\PYGZob{}}
      \PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{cstr} \PYG{o}{=} \PYG{n}{toCString}\PYG{p}{();}
      \PYG{n}{std}\PYG{o}{::}\PYG{n}{string} \PYG{n}{str}\PYG{p}{(}\PYG{n}{cstr}\PYG{p}{);}
      \PYG{n}{deleteCString}\PYG{p}{(}\PYG{n}{cstr}\PYG{p}{);}
      \PYG{k}{return} \PYG{n}{str}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

  \PYG{k}{private}\PYG{o}{:}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{toCString}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}
  \PYG{p}{\PYGZcb{};}

  \PYG{c+cm}{/**}
\PYG{c+cm}{   * The Frame class represents a set of hand and finger tracking data detected}
\PYG{c+cm}{   * in a single frame.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * The Leap Motion software detects hands, fingers and tools within the tracking area, reporting}
\PYG{c+cm}{   * their positions, orientations, gestures, and motions in frames at the Leap Motion frame rate.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * Access Frame objects through an instance of the Controller class:}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * \PYGZbs{}include Controller\PYGZus{}Frame\PYGZus{}1.txt}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * Implement a Listener subclass to receive a callback event when a new Frame is available.}
\PYG{c+cm}{   * @since 1.0}
\PYG{c+cm}{   */}
  \PYG{k}{class} \PYG{n+nc}{Frame} \PYG{o}{:} \PYG{k}{public} \PYG{n}{Interface} \PYG{p}{\PYGZob{}}
  \PYG{k}{public}\PYG{o}{:}
    \PYG{c+c1}{// For internal use only.}
    \PYG{n}{Frame}\PYG{p}{(}\PYG{n}{FrameImplementation}\PYG{o}{*}\PYG{p}{);}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Constructs a Frame object.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Frame instances created with this constructor are invalid.}
\PYG{c+cm}{     * Get valid Frame objects by calling the Controller::frame() function.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Frame\PYGZus{}Frame.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * The only time you should use this constructor is before deserializing}
\PYG{c+cm}{     * serialized frame data. Call ``Frame::deserialize(string)`` to recreate}
\PYG{c+cm}{     * a saved Frame.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n+nf}{Frame}\PYG{p}{();}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * A unique ID for this Frame.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Consecutive frames processed by the Leap Motion software have consecutive}
\PYG{c+cm}{     * increasing values. You can use the frame ID to avoid processing the same}
\PYG{c+cm}{     * Frame object twice:}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Frame\PYGZus{}Duplicate.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * As well as to make sure that your application processes every frame:}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Frame\PYGZus{}Skipped.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The frame ID.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{int64\PYGZus{}t} \PYG{n+nf}{id}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The frame capture time in microseconds elapsed since an arbitrary point in }
\PYG{c+cm}{     * time in the past.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Use Controller::now() to calculate the age of the frame.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Frame\PYGZus{}timestamp.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The timestamp in microseconds.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{int64\PYGZus{}t} \PYG{n+nf}{timestamp}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The list of Hand objects detected in this frame, given in arbitrary order.}
\PYG{c+cm}{     * The list can be empty if no hands are detected.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Frame\PYGZus{}hands.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The HandList containing all Hand objects detected in this frame.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{HandList} \PYG{n+nf}{hands}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The Hand object with the specified ID in this frame.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Use the Frame::hand() function to retrieve the Hand object from}
\PYG{c+cm}{     * this frame using an ID value obtained from a previous frame.}
\PYG{c+cm}{     * This function always returns a Hand object, but if no hand}
\PYG{c+cm}{     * with the specified ID is present, an invalid Hand object is returned.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Frame\PYGZus{}hand.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Note that ID values persist across frames, but only until tracking of a}
\PYG{c+cm}{     * particular object is lost. If tracking of a hand is lost and subsequently}
\PYG{c+cm}{     * regained, the new Hand object representing that physical hand may have}
\PYG{c+cm}{     * a different ID than that representing the physical hand in an earlier frame.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param id The ID value of a Hand object from a previous frame.}
\PYG{c+cm}{     * @returns The Hand object with the matching ID if one exists in this frame;}
\PYG{c+cm}{     * otherwise, an invalid Hand object is returned.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Hand} \PYG{n+nf}{hand}\PYG{p}{(}\PYG{k+kt}{int32\PYGZus{}t} \PYG{n}{id}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The list of Pointable objects (fingers and tools) detected in this frame,}
\PYG{c+cm}{     * given in arbitrary order. The list can be empty if no fingers or tools are detected.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Use PointableList::extended() to remove non\PYGZhy{}extended fingers from the list.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Frame\PYGZus{}pointables.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The PointableList containing all Pointable objects detected in this frame.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{PointableList} \PYG{n+nf}{pointables}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The Pointable object with the specified ID in this frame.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Use the Frame::pointable() function to retrieve the Pointable object from}
\PYG{c+cm}{     * this frame using an ID value obtained from a previous frame.}
\PYG{c+cm}{     * This function always returns a Pointable object, but if no finger or tool}
\PYG{c+cm}{     * with the specified ID is present, an invalid Pointable object is returned.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Frame\PYGZus{}pointable.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Note that ID values persist across frames, but only until tracking of a}
\PYG{c+cm}{     * particular object is lost. If tracking of a finger or tool is lost and subsequently}
\PYG{c+cm}{     * regained, the new Pointable object representing that finger or tool may have}
\PYG{c+cm}{     * a different ID than that representing the finger or tool in an earlier frame.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param id The ID value of a Pointable object from a previous frame.}
\PYG{c+cm}{     * @returns The Pointable object with the matching ID if one exists in this frame;}
\PYG{c+cm}{     * otherwise, an invalid Pointable object is returned.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Pointable} \PYG{n+nf}{pointable}\PYG{p}{(}\PYG{k+kt}{int32\PYGZus{}t} \PYG{n}{id}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The list of Finger objects detected in this frame, given in arbitrary order.}
\PYG{c+cm}{     * The list can be empty if no fingers are detected.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Use PointableList::extended() to remove non\PYGZhy{}extended fingers from the list.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Frame\PYGZus{}fingers.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The FingerList containing all Finger objects detected in this frame.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{FingerList} \PYG{n+nf}{fingers}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The Finger object with the specified ID in this frame.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Use the Frame::finger() function to retrieve the Finger object from}
\PYG{c+cm}{     * this frame using an ID value obtained from a previous frame.}
\PYG{c+cm}{     * This function always returns a Finger object, but if no finger}
\PYG{c+cm}{     * with the specified ID is present, an invalid Finger object is returned.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Frame\PYGZus{}finger.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Note that ID values persist across frames, but only until tracking of a}
\PYG{c+cm}{     * particular object is lost. If tracking of a finger is lost and subsequently}
\PYG{c+cm}{     * regained, the new Finger object representing that physical finger may have}
\PYG{c+cm}{     * a different ID than that representing the finger in an earlier frame.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param id The ID value of a Finger object from a previous frame.}
\PYG{c+cm}{     * @returns The Finger object with the matching ID if one exists in this frame;}
\PYG{c+cm}{     * otherwise, an invalid Finger object is returned.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Finger} \PYG{n+nf}{finger}\PYG{p}{(}\PYG{k+kt}{int32\PYGZus{}t} \PYG{n}{id}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The list of Tool objects detected in this frame, given in arbitrary order.}
\PYG{c+cm}{     * The list can be empty if no tools are detected.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Frame\PYGZus{}tools.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The ToolList containing all Tool objects detected in this frame.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{ToolList} \PYG{n+nf}{tools}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The Tool object with the specified ID in this frame.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Use the Frame::tool() function to retrieve the Tool object from}
\PYG{c+cm}{     * this frame using an ID value obtained from a previous frame.}
\PYG{c+cm}{     * This function always returns a Tool object, but if no tool}
\PYG{c+cm}{     * with the specified ID is present, an invalid Tool object is returned.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Frame\PYGZus{}tool.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Note that ID values persist across frames, but only until tracking of a}
\PYG{c+cm}{     * particular object is lost. If tracking of a tool is lost and subsequently}
\PYG{c+cm}{     * regained, the new Tool object representing that tool may have a}
\PYG{c+cm}{     * different ID than that representing the tool in an earlier frame.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param id The ID value of a Tool object from a previous frame.}
\PYG{c+cm}{     * @returns The Tool object with the matching ID if one exists in this frame;}
\PYG{c+cm}{     * otherwise, an invalid Tool object is returned.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Tool} \PYG{n+nf}{tool}\PYG{p}{(}\PYG{k+kt}{int32\PYGZus{}t} \PYG{n}{id}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The Gesture object with the specified ID in this frame.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Use the Frame::gesture() function to return a Gesture object in this}
\PYG{c+cm}{     * frame using an ID obtained in an earlier frame. The function always}
\PYG{c+cm}{     * returns a Gesture object, but if there was no update for the gesture in}
\PYG{c+cm}{     * this frame, then an invalid Gesture object is returned.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Frame\PYGZus{}gesture.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * All Gesture objects representing the same recognized movement share the}
\PYG{c+cm}{     * same ID.}
\PYG{c+cm}{     * @param id The ID of an Gesture object from a previous frame.}
\PYG{c+cm}{     * @returns The Gesture object in the frame with the specified ID if one}
\PYG{c+cm}{     * exists; Otherwise, an Invalid Gesture object.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Gesture} \PYG{n+nf}{gesture}\PYG{p}{(}\PYG{k+kt}{int32\PYGZus{}t} \PYG{n}{id}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The gestures recognized or continuing in this frame.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Frame\PYGZus{}gestures\PYGZus{}now.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Circle and swipe gestures are updated every frame. Tap gestures}
\PYG{c+cm}{     * only appear in the list  for a single frame.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @return GestureList the list of gestures.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{GestureList} \PYG{n+nf}{gestures}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Returns a GestureList containing all gestures that have occurred since}
\PYG{c+cm}{     * the specified frame.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Frame\PYGZus{}gestures\PYGZus{}since.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param sinceFrame An earlier Frame object. The starting frame must}
\PYG{c+cm}{     * still be in the frame history cache, which has a default length of}
\PYG{c+cm}{     * 60 frames.}
\PYG{c+cm}{     * @return GestureList The list of the Gesture objects that have occurred}
\PYG{c+cm}{     * since the specified frame.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{GestureList} \PYG{n+nf}{gestures}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Frame}\PYG{o}{\PYGZam{}} \PYG{n}{sinceFrame}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The list of images from the Leap Motion cameras.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @return An ImageList object containing the camera images analyzed to create this Frame.}
\PYG{c+cm}{     * @since 2.1}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{ImageList} \PYG{n+nf}{images}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The change of position derived from the overall linear motion between}
\PYG{c+cm}{     * the current frame and the specified frame.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * The returned translation vector provides the magnitude and direction of}
\PYG{c+cm}{     * the movement in millimeters.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Frame\PYGZus{}translation.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * The Leap Motion software derives frame translation from the linear motion of}
\PYG{c+cm}{     * all objects detected in the field of view.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * If either this frame or sinceFrame is an invalid Frame object, then this}
\PYG{c+cm}{     * method returns a zero vector.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param sinceFrame The starting frame for computing the relative translation.}
\PYG{c+cm}{     * @returns A Vector representing the heuristically determined change in}
\PYG{c+cm}{     * position of all objects between the current frame and that specified}
\PYG{c+cm}{     * in the sinceFrame parameter.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Vector} \PYG{n+nf}{translation}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Frame}\PYG{o}{\PYGZam{}} \PYG{n}{sinceFrame}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The estimated probability that the overall motion between the current}
\PYG{c+cm}{     * frame and the specified frame is intended to be a translating motion.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Frame\PYGZus{}translationProbability.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * If either this frame or sinceFrame is an invalid Frame object, then this}
\PYG{c+cm}{     * method returns zero.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param sinceFrame The starting frame for computing the translation.}
\PYG{c+cm}{     * @returns A value between 0 and 1 representing the estimated probability}
\PYG{c+cm}{     * that the overall motion between the current frame and the specified frame}
\PYG{c+cm}{     * is intended to be a translating motion.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{float} \PYG{n+nf}{translationProbability}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Frame}\PYG{o}{\PYGZam{}} \PYG{n}{sinceFrame}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The axis of rotation derived from the overall rotational motion between}
\PYG{c+cm}{     * the current frame and the specified frame.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * The returned direction vector is normalized.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Frame\PYGZus{}rotationAxis.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * The Leap Motion software derives frame rotation from the relative change in position and}
\PYG{c+cm}{     * orientation of all objects detected in the field of view.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * If either this frame or sinceFrame is an invalid Frame object, or if no}
\PYG{c+cm}{     * rotation is detected between the two frames, a zero vector is returned.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param sinceFrame The starting frame for computing the relative rotation.}
\PYG{c+cm}{     * @returns A normalized direction Vector representing the axis of the}
\PYG{c+cm}{     * heuristically determined rotational change between the current frame}
\PYG{c+cm}{     * and that specified in the sinceFrame parameter.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Vector} \PYG{n+nf}{rotationAxis}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Frame}\PYG{o}{\PYGZam{}} \PYG{n}{sinceFrame}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The angle of rotation around the rotation axis derived from the overall}
\PYG{c+cm}{     * rotational motion between the current frame and the specified frame.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * The returned angle is expressed in radians measured clockwise around the}
\PYG{c+cm}{     * rotation axis (using the right\PYGZhy{}hand rule) between the start and end frames.}
\PYG{c+cm}{     * The value is always between 0 and pi radians (0 and 180 degrees).}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Frame\PYGZus{}rotationAngle.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * The Leap Motion software derives frame rotation from the relative change in position and}
\PYG{c+cm}{     * orientation of all objects detected in the field of view.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * If either this frame or sinceFrame is an invalid Frame object, then the}
\PYG{c+cm}{     * angle of rotation is zero.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param sinceFrame The starting frame for computing the relative rotation.}
\PYG{c+cm}{     * @returns A positive value containing the heuristically determined}
\PYG{c+cm}{     * rotational change between the current frame and that specified in the}
\PYG{c+cm}{     * sinceFrame parameter.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{float} \PYG{n+nf}{rotationAngle}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Frame}\PYG{o}{\PYGZam{}} \PYG{n}{sinceFrame}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The angle of rotation around the specified axis derived from the overall}
\PYG{c+cm}{     * rotational motion between the current frame and the specified frame.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * The returned angle is expressed in radians measured clockwise around the}
\PYG{c+cm}{     * rotation axis (using the right\PYGZhy{}hand rule) between the start and end frames.}
\PYG{c+cm}{     * The value is always between \PYGZhy{}pi and pi radians (\PYGZhy{}180 and 180 degrees).}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Frame\PYGZus{}rotationAngle\PYGZus{}axis.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * The Leap Motion software derives frame rotation from the relative change in position and}
\PYG{c+cm}{     * orientation of all objects detected in the field of view.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * If either this frame or sinceFrame is an invalid Frame object, then the}
\PYG{c+cm}{     * angle of rotation is zero.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param sinceFrame The starting frame for computing the relative rotation.}
\PYG{c+cm}{     * @param axis The axis to measure rotation around.}
\PYG{c+cm}{     * @returns A value containing the heuristically determined rotational}
\PYG{c+cm}{     * change between the current frame and that specified in the sinceFrame}
\PYG{c+cm}{     * parameter around the given axis.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{float} \PYG{n+nf}{rotationAngle}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Frame}\PYG{o}{\PYGZam{}} \PYG{n}{sinceFrame}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZam{}} \PYG{n}{axis}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The transform matrix expressing the rotation derived from the overall}
\PYG{c+cm}{     * rotational motion between the current frame and the specified frame.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Frame\PYGZus{}rotationMatrix.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * The Leap Motion software derives frame rotation from the relative change in position and}
\PYG{c+cm}{     * orientation of all objects detected in the field of view.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * If either this frame or sinceFrame is an invalid Frame object, then this}
\PYG{c+cm}{     * method returns an identity matrix.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param sinceFrame The starting frame for computing the relative rotation.}
\PYG{c+cm}{     * @returns A transformation Matrix containing the heuristically determined}
\PYG{c+cm}{     * rotational change between the current frame and that specified in the}
\PYG{c+cm}{     * sinceFrame parameter.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Matrix} \PYG{n+nf}{rotationMatrix}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Frame}\PYG{o}{\PYGZam{}} \PYG{n}{sinceFrame}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The estimated probability that the overall motion between the current}
\PYG{c+cm}{     * frame and the specified frame is intended to be a rotating motion.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Frame\PYGZus{}rotationProbability.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * If either this frame or sinceFrame is an invalid Frame object, then this}
\PYG{c+cm}{     * method returns zero.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param sinceFrame The starting frame for computing the relative rotation.}
\PYG{c+cm}{     * @returns A value between 0 and 1 representing the estimated probability}
\PYG{c+cm}{     * that the overall motion between the current frame and the specified frame}
\PYG{c+cm}{     * is intended to be a rotating motion.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{float} \PYG{n+nf}{rotationProbability}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Frame}\PYG{o}{\PYGZam{}} \PYG{n}{sinceFrame}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The scale factor derived from the overall motion between the current frame}
\PYG{c+cm}{     * and the specified frame.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * The scale factor is always positive. A value of 1.0 indicates no}
\PYG{c+cm}{     * scaling took place. Values between 0.0 and 1.0 indicate contraction}
\PYG{c+cm}{     * and values greater than 1.0 indicate expansion.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Frame\PYGZus{}scaleFactor.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * The Leap Motion software derives scaling from the relative inward or outward motion of}
\PYG{c+cm}{     * all objects detected in the field of view (independent of translation}
\PYG{c+cm}{     * and rotation).}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * If either this frame or sinceFrame is an invalid Frame object, then this}
\PYG{c+cm}{     * method returns 1.0.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param sinceFrame The starting frame for computing the relative scaling.}
\PYG{c+cm}{     * @returns A positive value representing the heuristically determined}
\PYG{c+cm}{     * scaling change ratio between the current frame and that specified in the}
\PYG{c+cm}{     * sinceFrame parameter.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{float} \PYG{n+nf}{scaleFactor}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Frame}\PYG{o}{\PYGZam{}} \PYG{n}{sinceFrame}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The estimated probability that the overall motion between the current}
\PYG{c+cm}{     * frame and the specified frame is intended to be a scaling motion.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Frame\PYGZus{}scaleProbability.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * If either this frame or sinceFrame is an invalid Frame object, then this}
\PYG{c+cm}{     * method returns zero.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param sinceFrame The starting frame for computing the relative scaling.}
\PYG{c+cm}{     * @returns A value between 0 and 1 representing the estimated probability}
\PYG{c+cm}{     * that the overall motion between the current frame and the specified frame}
\PYG{c+cm}{     * is intended to be a scaling motion.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{float} \PYG{n+nf}{scaleProbability}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Frame}\PYG{o}{\PYGZam{}} \PYG{n}{sinceFrame}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The current InteractionBox for the frame. See the InteractionBox class}
\PYG{c+cm}{     * documentation for more details on how this class should be used.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Frame\PYGZus{}interactionBox.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The current InteractionBox object.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{InteractionBox} \PYG{n+nf}{interactionBox}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The instantaneous framerate.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * The rate at which the Leap Motion software is providing frames of data}
\PYG{c+cm}{     * (in frames per second). The framerate can fluctuate depending on available computing}
\PYG{c+cm}{     * resources, activity within the device field of view, software tracking settings,}
\PYG{c+cm}{     * and other factors.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Frame\PYGZus{}currentFramesPerSecond.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns An estimate of frames per second of the Leap Motion Controller.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{float} \PYG{n+nf}{currentFramesPerSecond}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Reports whether this Frame instance is valid.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * A valid Frame is one generated by the Leap::Controller object that contains}
\PYG{c+cm}{     * tracking data for all detected entities. An invalid Frame contains no}
\PYG{c+cm}{     * actual tracking data, but you can call its functions without risk of a}
\PYG{c+cm}{     * null pointer exception. The invalid Frame mechanism makes it more}
\PYG{c+cm}{     * convenient to track individual data across the frame history. For example,}
\PYG{c+cm}{     * you can invoke:}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Frame\PYGZus{}Valid\PYGZus{}Chain.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * for an arbitrary Frame history value, \PYGZdq{}n\PYGZdq{}, without first checking whether}
\PYG{c+cm}{     * frame(n) returned a null object. (You should still check that the}
\PYG{c+cm}{     * returned Finger instance is valid.)}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns True, if this is a valid Frame object; false otherwise.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{n+nf}{isValid}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Returns an invalid Frame object.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * You can use the instance returned by this function in comparisons testing}
\PYG{c+cm}{     * whether a given Frame instance is valid or invalid. (You can also use the}
\PYG{c+cm}{     * Frame::isValid() function.)}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Frame\PYGZus{}Invalid\PYGZus{}Demo.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The invalid Frame instance.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{static} \PYG{k}{const} \PYG{n}{Frame}\PYG{o}{\PYGZam{}} \PYG{n}{invalid}\PYG{p}{();}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Compare Frame object equality.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Frame\PYGZus{}operator\PYGZus{}equals.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Two Frame objects are equal if and only if both Frame objects represent}
\PYG{c+cm}{     * the exact same frame of tracking data and both Frame objects are valid.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{k}{operator}\PYG{o}{==}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Frame}\PYG{o}{\PYGZam{}}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Compare Frame object inequality.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Frame\PYGZus{}operator\PYGZus{}not\PYGZus{}equals.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Two Frame objects are equal if and only if both Frame objects represent}
\PYG{c+cm}{     * the exact same frame of tracking data and both Frame objects are valid.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{k}{operator}\PYG{o}{!=}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Frame}\PYG{o}{\PYGZam{}}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Writes a brief, human readable description of the Frame object to an output stream.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Frame\PYGZus{}operator\PYGZus{}stream.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{friend} \PYG{n}{std}\PYG{o}{::}\PYG{n}{ostream}\PYG{o}{\PYGZam{}} \PYG{k}{operator}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{p}{(}\PYG{n}{std}\PYG{o}{::}\PYG{n}{ostream}\PYG{o}{\PYGZam{}}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Frame}\PYG{o}{\PYGZam{}}\PYG{p}{);}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Note: This class is an experimental API for internal use only. It may be}
\PYG{c+cm}{     * removed without warning.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Returns information about the currently detected quad in the scene.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Frame\PYGZus{}trackedQuad.txt}
\PYG{c+cm}{     * If no quad is being tracked, then an invalid TrackedQuad is returned.}
\PYG{c+cm}{     * @since 2.2.6}
\PYG{c+cm}{     **/}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{TrackedQuad} \PYG{n+nf}{trackedQuad}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Encodes this Frame object as a byte string.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Frame\PYGZus{}serialize.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The serialized string encoding the data for this frame.}
\PYG{c+cm}{     * @since 2.1.0}
\PYG{c+cm}{     */}
    \PYG{n}{std}\PYG{o}{::}\PYG{n}{string} \PYG{n}{serialize}\PYG{p}{()} \PYG{k}{const} \PYG{p}{\PYGZob{}}
      \PYG{k+kt}{size\PYGZus{}t} \PYG{n}{length} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
      \PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{cstr} \PYG{o}{=} \PYG{n}{serializeCString}\PYG{p}{(}\PYG{n}{length}\PYG{p}{);}
      \PYG{n}{std}\PYG{o}{::}\PYG{n}{string} \PYG{n}{str}\PYG{p}{(}\PYG{n}{cstr}\PYG{p}{,} \PYG{n}{length}\PYG{p}{);}
      \PYG{n}{deleteCString}\PYG{p}{(}\PYG{n}{cstr}\PYG{p}{);}
      \PYG{k}{return} \PYG{n}{str}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Decodes a byte string to replace the properties of this Frame.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * A Controller object must be instantiated for this function to succeed, but}
\PYG{c+cm}{     * it does not need to be connected. To extract gestures from the deserialized}
\PYG{c+cm}{     * frame, you must enable the appropriate gestures first.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Any existing data in the frame is}
\PYG{c+cm}{     * destroyed. If you have references to}
\PYG{c+cm}{     * child objects (hands, fingers, etc.), these are preserved as long as the}
\PYG{c+cm}{     * references remain in scope.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Frame\PYGZus{}deserialize.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * **Note:** The behavior when calling functions which take}
\PYG{c+cm}{     * another Frame object as a parameter is undefined when either frame has}
\PYG{c+cm}{     * been deserialized. For example, calling ``gestures(sinceFrame)`` on a}
\PYG{c+cm}{     * deserialized frame or with a deserialized frame as parameter (or both)}
\PYG{c+cm}{     * does not necessarily return all gestures that occurred between the two}
\PYG{c+cm}{     * frames. Motion functions, like ``scaleFactor(startFrame)``, are more}
\PYG{c+cm}{     * likely to return reasonable results, but could return anomalous values}
\PYG{c+cm}{     * in some cases.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param str A std:string object containing the serialized bytes of a frame.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @since 2.1.0}
\PYG{c+cm}{     */}
    \PYG{k+kt}{void} \PYG{n}{deserialize}\PYG{p}{(}\PYG{k}{const} \PYG{n}{std}\PYG{o}{::}\PYG{n}{string}\PYG{o}{\PYGZam{}} \PYG{n}{str}\PYG{p}{)} \PYG{p}{\PYGZob{}}
      \PYG{n}{deserializeCString}\PYG{p}{(}\PYG{n}{str}\PYG{p}{.}\PYG{n}{data}\PYG{p}{(),} \PYG{n}{str}\PYG{p}{.}\PYG{n}{length}\PYG{p}{());}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+cm}{/*}
\PYG{c+cm}{     * Do not call this version of serialize(). It is intended only as}
\PYG{c+cm}{     * a helper for C\PYGZsh{}, Java, and other language bindings.}
\PYG{c+cm}{     */}
    \PYG{k+kt}{void} \PYG{n}{serialize}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{ptr}\PYG{p}{)} \PYG{k}{const} \PYG{p}{\PYGZob{}}
      \PYG{k+kt}{size\PYGZus{}t} \PYG{n}{length}\PYG{p}{;}
      \PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{cstr} \PYG{o}{=} \PYG{k}{reinterpret\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{char}\PYG{o}{*\PYGZgt{}}\PYG{p}{(}\PYG{n}{serializeCString}\PYG{p}{(}\PYG{n}{length}\PYG{p}{));}
      \PYG{n}{memcpy}\PYG{p}{(}\PYG{n}{ptr}\PYG{p}{,} \PYG{n}{cstr}\PYG{p}{,} \PYG{n}{length} \PYG{o}{*} \PYG{k}{sizeof}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{char}\PYG{p}{));}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+cm}{/*}
\PYG{c+cm}{     * Do not call serializeLength(). It is intended only as a helper for}
\PYG{c+cm}{     * C\PYGZsh{}, Java, and other language bindings. To get the length of the}
\PYG{c+cm}{     * serialized byte array, use serialize().length()}
\PYG{c+cm}{     */}
    \PYG{k+kt}{int} \PYG{n}{serializeLength}\PYG{p}{()} \PYG{k}{const} \PYG{p}{\PYGZob{}}
      \PYG{k+kt}{size\PYGZus{}t} \PYG{n}{length} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
      \PYG{n}{serializeCString}\PYG{p}{(}\PYG{n}{length}\PYG{p}{);}
      \PYG{k}{return} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{length}\PYG{p}{);}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+cm}{/*}
\PYG{c+cm}{     * Do not call this version of deserialize(). It is intended only as}
\PYG{c+cm}{     * a helper for C\PYGZsh{}, Java, and other language bindings.}
\PYG{c+cm}{     */}
    \PYG{k+kt}{void} \PYG{n}{deserialize}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{unsigned} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{ptr}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{length}\PYG{p}{)} \PYG{p}{\PYGZob{}}
      \PYG{n}{deserializeCString}\PYG{p}{(}\PYG{k}{reinterpret\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*\PYGZgt{}}\PYG{p}{(}\PYG{n}{ptr}\PYG{p}{),} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{size\PYGZus{}t}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{length}\PYG{p}{));}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * A string containing a brief, human readable description of the Frame object.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns A description of the Frame as a string.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{std}\PYG{o}{::}\PYG{n}{string} \PYG{n}{toString}\PYG{p}{()} \PYG{k}{const} \PYG{p}{\PYGZob{}}
      \PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{cstr} \PYG{o}{=} \PYG{n}{toCString}\PYG{p}{();}
      \PYG{n}{std}\PYG{o}{::}\PYG{n}{string} \PYG{n}{str}\PYG{p}{(}\PYG{n}{cstr}\PYG{p}{);}
      \PYG{n}{deleteCString}\PYG{p}{(}\PYG{n}{cstr}\PYG{p}{);}
      \PYG{k}{return} \PYG{n}{str}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

  \PYG{k}{private}\PYG{o}{:}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{toCString}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n+nf}{serializeCString}\PYG{p}{(}\PYG{k+kt}{size\PYGZus{}t}\PYG{o}{\PYGZam{}} \PYG{n}{length}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{void} \PYG{n+nf}{deserializeCString}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{str}\PYG{p}{,} \PYG{k+kt}{size\PYGZus{}t} \PYG{n}{length}\PYG{p}{);}
  \PYG{p}{\PYGZcb{};}

  \PYG{c+cm}{/* For internal use only. */}
  \PYG{k}{class} \PYG{n+nc}{BugReport} \PYG{o}{:} \PYG{k}{public} \PYG{n}{Interface} \PYG{p}{\PYGZob{}}
  \PYG{k}{public}\PYG{o}{:}
    \PYG{c+c1}{// For internal use only}
    \PYG{n}{BugReport}\PYG{p}{(}\PYG{n}{BugReportImplementation}\PYG{o}{*}\PYG{p}{);}

    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n+nf}{BugReport}\PYG{p}{();}

    \PYG{c+cm}{/* Starts recording data. The recording ends when endRecording() is called}
\PYG{c+cm}{    * or after 10 seconds. The recording is saved to the local hard drive. */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{n+nf}{beginRecording}\PYG{p}{();}
    \PYG{c+cm}{/* Ends the recording. */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{void} \PYG{n+nf}{endRecording}\PYG{p}{();}

    \PYG{c+cm}{/* True while recording is in progress. */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{n+nf}{isActive}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}
    \PYG{c+cm}{/* Progress as a fraction of the maximum recording length (i.e. 10 seconds).}
\PYG{c+cm}{    * The range of the progress value is [0..1]. */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{float} \PYG{n+nf}{progress}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}
    \PYG{c+cm}{/* The recording duration in seconds. */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{float} \PYG{n+nf}{duration}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}
  \PYG{p}{\PYGZcb{};}

  \PYG{c+cm}{/**}
\PYG{c+cm}{   * The Config class provides access to Leap Motion system configuration information.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * You can get and set gesture configuration parameters using the Config object}
\PYG{c+cm}{   * obtained from a connected Controller object. The key strings required to}
\PYG{c+cm}{   * identify a configuration parameter include:}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * \PYGZbs{}table}
\PYG{c+cm}{   * ====================================  ========== ============= =======}
\PYG{c+cm}{   * Key string                            Value type Default value Units}
\PYG{c+cm}{   * ====================================  ========== ============= =======}
\PYG{c+cm}{   * Gesture.Circle.MinRadius              float      5.0           mm}
\PYG{c+cm}{   * Gesture.Circle.MinArc                 float      1.5 * pi      radians}
\PYG{c+cm}{   * Gesture.Swipe.MinLength               float      150           mm}
\PYG{c+cm}{   * Gesture.Swipe.MinVelocity             float      1000          mm/s}
\PYG{c+cm}{   * Gesture.KeyTap.MinDownVelocity        float      50            mm/s}
\PYG{c+cm}{   * Gesture.KeyTap.HistorySeconds         float      0.1           s}
\PYG{c+cm}{   * Gesture.KeyTap.MinDistance            float      3.0           mm}
\PYG{c+cm}{   * Gesture.ScreenTap.MinForwardVelocity  float      50            mm/s}
\PYG{c+cm}{   * Gesture.ScreenTap.HistorySeconds      float      0.1           s}
\PYG{c+cm}{   * Gesture.ScreenTap.MinDistance         float      5.0           mm}
\PYG{c+cm}{   * ====================================  ========== ============= =======}
\PYG{c+cm}{   * \PYGZbs{}endtable}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * After setting a configuration value, you must call the Config::save() method}
\PYG{c+cm}{   * to commit the changes. You can save after the Controller has connected to}
\PYG{c+cm}{   * the Leap Motion service/daemon. In other words, after the Controller}
\PYG{c+cm}{   * has dispatched the serviceConnected or connected events or}
\PYG{c+cm}{   * Controller::isConnected is true. The configuration value changes are}
\PYG{c+cm}{   * not persistent; your application needs to set the values every time it runs.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * @see CircleGesture}
\PYG{c+cm}{   * @see KeyTapGesture}
\PYG{c+cm}{   * @see ScreenTapGesture}
\PYG{c+cm}{   * @see SwipeGesture}
\PYG{c+cm}{   * @since 1.0}
\PYG{c+cm}{   */}
  \PYG{k}{class} \PYG{n+nc}{Config} \PYG{o}{:} \PYG{k}{public} \PYG{n}{Interface} \PYG{p}{\PYGZob{}}
  \PYG{k}{public}\PYG{o}{:}
    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Constructs a Config object.}
\PYG{c+cm}{     * Do not create your own Config objects. Get a Config object using}
\PYG{c+cm}{     * the Controller::config() function.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Config\PYGZus{}Constructor.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Config}\PYG{p}{();}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Enumerates the possible data types for configuration values.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * The Config::type() function returns an item from the ValueType enumeration.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{k}{enum} \PYG{n}{ValueType} \PYG{p}{\PYGZob{}}
      \PYG{c+cm}{/**}
\PYG{c+cm}{       * The data type is unknown.}
\PYG{c+cm}{       * @since 1.0}
\PYG{c+cm}{       */}
      \PYG{n}{TYPE\PYGZus{}UNKNOWN} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,}
      \PYG{c+cm}{/**}
\PYG{c+cm}{       * A boolean value.}
\PYG{c+cm}{       * @since 1.0}
\PYG{c+cm}{       */}
      \PYG{n}{TYPE\PYGZus{}BOOLEAN} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,}
      \PYG{c+cm}{/**}
\PYG{c+cm}{       * A 32\PYGZhy{}bit integer.}
\PYG{c+cm}{       * @since 1.0}
\PYG{c+cm}{       */}
      \PYG{n}{TYPE\PYGZus{}INT32}   \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{,}
      \PYG{c+cm}{/**}
\PYG{c+cm}{       * A floating\PYGZhy{}point number.}
\PYG{c+cm}{       * @since 1.0}
\PYG{c+cm}{       */}
      \PYG{n}{TYPE\PYGZus{}FLOAT}   \PYG{o}{=} \PYG{l+m+mi}{6}\PYG{p}{,}
      \PYG{c+cm}{/**}
\PYG{c+cm}{       * A string of characters.}
\PYG{c+cm}{       * @since 1.0}
\PYG{c+cm}{       */}
      \PYG{n}{TYPE\PYGZus{}STRING}  \PYG{o}{=} \PYG{l+m+mi}{8}\PYG{p}{,}
\PYG{c+cp}{\PYGZsh{}ifdef SWIGCSHARP}
      \PYG{c+c1}{// deprecated}
      \PYG{n}{TYPEUNKNOWN}  \PYG{o}{=} \PYG{n}{TYPE\PYGZus{}UNKNOWN}\PYG{p}{,}
      \PYG{n}{TYPEBOOLEAN}  \PYG{o}{=} \PYG{n}{TYPE\PYGZus{}BOOLEAN}\PYG{p}{,}
      \PYG{n}{TYPEINT32}    \PYG{o}{=} \PYG{n}{TYPE\PYGZus{}INT32}\PYG{p}{,}
      \PYG{n}{TYPEFLOAT}    \PYG{o}{=} \PYG{n}{TYPE\PYGZus{}FLOAT}\PYG{p}{,}
      \PYG{n}{TYPESTRING}   \PYG{o}{=} \PYG{n}{TYPE\PYGZus{}STRING}\PYG{p}{,}
\PYG{c+cp}{\PYGZsh{}endif}
    \PYG{p}{\PYGZcb{};}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Reports the natural data type for the value related to the specified key.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Config\PYGZus{}type.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param key The key for the looking up the value in the configuration dictionary.}
\PYG{c+cm}{     * @returns The native data type of the value, that is, the type that does not}
\PYG{c+cm}{     * require a data conversion.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{ValueType} \PYG{n+nf}{type}\PYG{p}{(}\PYG{k}{const} \PYG{n}{std}\PYG{o}{::}\PYG{n}{string}\PYG{o}{\PYGZam{}} \PYG{n}{key}\PYG{p}{)} \PYG{k}{const} \PYG{p}{\PYGZob{}}
      \PYG{k}{return} \PYG{n}{typeCString}\PYG{p}{(}\PYG{n}{key}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{());}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Gets the boolean representation for the specified key.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Config\PYGZus{}getBool.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{k+kt}{bool} \PYG{n+nf}{getBool}\PYG{p}{(}\PYG{k}{const} \PYG{n}{std}\PYG{o}{::}\PYG{n}{string}\PYG{o}{\PYGZam{}} \PYG{n}{key}\PYG{p}{)} \PYG{k}{const} \PYG{p}{\PYGZob{}}
      \PYG{k}{return} \PYG{n}{getBoolCString}\PYG{p}{(}\PYG{n}{key}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{());}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+cm}{/** Sets the boolean representation for the specified key.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Config\PYGZus{}setBool.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns true on success, false on failure.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{k+kt}{bool} \PYG{n+nf}{setBool}\PYG{p}{(}\PYG{k}{const} \PYG{n}{std}\PYG{o}{::}\PYG{n}{string}\PYG{o}{\PYGZam{}} \PYG{n}{key}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{n}{value}\PYG{p}{)} \PYG{p}{\PYGZob{}}
      \PYG{k}{return} \PYG{n}{setBoolCString}\PYG{p}{(}\PYG{n}{key}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(),} \PYG{n}{value}\PYG{p}{);}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Gets the 32\PYGZhy{}bit integer representation for the specified key.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Config\PYGZus{}getInt32.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{k+kt}{int32\PYGZus{}t} \PYG{n+nf}{getInt32}\PYG{p}{(}\PYG{k}{const} \PYG{n}{std}\PYG{o}{::}\PYG{n}{string}\PYG{o}{\PYGZam{}} \PYG{n}{key}\PYG{p}{)} \PYG{k}{const} \PYG{p}{\PYGZob{}}
      \PYG{k}{return} \PYG{n}{getInt32CString}\PYG{p}{(}\PYG{n}{key}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{());}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+cm}{/** Sets the 32\PYGZhy{}bit integer representation for the specified key.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Config\PYGZus{}setInt32.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns true on success, false on failure.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{k+kt}{bool} \PYG{n+nf}{setInt32}\PYG{p}{(}\PYG{k}{const} \PYG{n}{std}\PYG{o}{::}\PYG{n}{string}\PYG{o}{\PYGZam{}} \PYG{n}{key}\PYG{p}{,} \PYG{k+kt}{int32\PYGZus{}t} \PYG{n}{value}\PYG{p}{)} \PYG{p}{\PYGZob{}}
      \PYG{k}{return} \PYG{n}{setInt32CString}\PYG{p}{(}\PYG{n}{key}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(),} \PYG{n}{value}\PYG{p}{);}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Gets the floating point representation for the specified key.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Config\PYGZus{}getFloat.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{k+kt}{float} \PYG{n+nf}{getFloat}\PYG{p}{(}\PYG{k}{const} \PYG{n}{std}\PYG{o}{::}\PYG{n}{string}\PYG{o}{\PYGZam{}} \PYG{n}{key}\PYG{p}{)} \PYG{k}{const} \PYG{p}{\PYGZob{}}
      \PYG{k}{return} \PYG{n}{getFloatCString}\PYG{p}{(}\PYG{n}{key}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{());}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+cm}{/** Sets the floating point representation for the specified key.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Config\PYGZus{}setFloat.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns true on success, false on failure.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{k+kt}{bool} \PYG{n+nf}{setFloat}\PYG{p}{(}\PYG{k}{const} \PYG{n}{std}\PYG{o}{::}\PYG{n}{string}\PYG{o}{\PYGZam{}} \PYG{n}{key}\PYG{p}{,} \PYG{k+kt}{float} \PYG{n}{value}\PYG{p}{)} \PYG{p}{\PYGZob{}}
      \PYG{k}{return} \PYG{n}{setFloatCString}\PYG{p}{(}\PYG{n}{key}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(),} \PYG{n}{value}\PYG{p}{);}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Gets the string representation for the specified key.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Config\PYGZus{}getString.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{std}\PYG{o}{::}\PYG{n}{string} \PYG{n}{getString}\PYG{p}{(}\PYG{k}{const} \PYG{n}{std}\PYG{o}{::}\PYG{n}{string}\PYG{o}{\PYGZam{}} \PYG{n}{key}\PYG{p}{)} \PYG{k}{const} \PYG{p}{\PYGZob{}}
      \PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{cstr} \PYG{o}{=} \PYG{n}{getStringCString}\PYG{p}{(}\PYG{n}{key}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{());}
      \PYG{n}{std}\PYG{o}{::}\PYG{n}{string} \PYG{n}{str}\PYG{p}{(}\PYG{n}{cstr}\PYG{p}{);}
      \PYG{n}{deleteCString}\PYG{p}{(}\PYG{n}{cstr}\PYG{p}{);}
      \PYG{k}{return} \PYG{n}{str}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+cm}{/** Sets the string representation for the specified key.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Config\PYGZus{}setString.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns true on success, false on failure.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{k+kt}{bool} \PYG{n}{setString}\PYG{p}{(}\PYG{k}{const} \PYG{n}{std}\PYG{o}{::}\PYG{n}{string}\PYG{o}{\PYGZam{}} \PYG{n}{key}\PYG{p}{,} \PYG{k}{const} \PYG{n}{std}\PYG{o}{::}\PYG{n}{string}\PYG{o}{\PYGZam{}} \PYG{n}{value}\PYG{p}{)} \PYG{p}{\PYGZob{}}
      \PYG{k}{return} \PYG{n}{setStringCString}\PYG{p}{(}\PYG{n}{key}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(),} \PYG{n}{value}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{());}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Saves the current state of the config.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Call ``save()`` after making a set of configuration changes. The}
\PYG{c+cm}{     * ``save()`` function transfers the configuration changes to the Leap Motion}
\PYG{c+cm}{     * service. You can save after the Controller has connected to}
\PYG{c+cm}{     * the Leap Motion service/daemon. In other words, after the Controller}
\PYG{c+cm}{     * has dispatched the serviceConnected or connected events or}
\PYG{c+cm}{     * Controller::isConnected is true. The configuration value changes are not persistent; your}
\PYG{c+cm}{     * application must set the values every time it runs.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Config\PYGZus{}save.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns true on success, false on failure.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{n}{save}\PYG{p}{();}
  \PYG{k}{private}\PYG{o}{:}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{ValueType} \PYG{n}{typeCString}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{key}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{n+nf}{getBoolCString}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{key}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{n+nf}{setBoolCString}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{key}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{n}{value}\PYG{p}{);}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{int32\PYGZus{}t} \PYG{n+nf}{getInt32CString}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{key}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{n+nf}{setInt32CString}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{key}\PYG{p}{,} \PYG{k+kt}{int32\PYGZus{}t} \PYG{n}{value}\PYG{p}{);}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{float} \PYG{n+nf}{getFloatCString}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{key}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{n+nf}{setFloatCString}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{key}\PYG{p}{,} \PYG{k+kt}{float} \PYG{n}{value}\PYG{p}{);}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n+nf}{getStringCString}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{key}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{n+nf}{setStringCString}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{key}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{value}\PYG{p}{);}
  \PYG{p}{\PYGZcb{};}

  \PYG{c+cm}{/**}
\PYG{c+cm}{   * The Controller class is your main interface to the Leap Motion Controller.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * Create an instance of this Controller class to access frames of tracking}
\PYG{c+cm}{   * data and configuration information. Frame data can be polled at any time}
\PYG{c+cm}{   * using the Controller::frame() function. Call frame() or frame(0) to get the}
\PYG{c+cm}{   * most recent frame. Set the history parameter to a positive integer to access}
\PYG{c+cm}{   * previous frames. A controller stores up to 60 frames in its frame history.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * Polling is an appropriate strategy for applications which already have an}
\PYG{c+cm}{   * intrinsic update loop, such as a game. You can also add an instance of a}
\PYG{c+cm}{   * subclass of Leap::Listener to the controller to handle events as they occur.}
\PYG{c+cm}{   * The Controller dispatches events to the listener upon initialization and exiting,}
\PYG{c+cm}{   * on connection changes, when the application gains and loses the OS input focus,}
\PYG{c+cm}{   * and when a new frame of tracking data is available.}
\PYG{c+cm}{   * When these events occur, the controller object invokes the appropriate}
\PYG{c+cm}{   * callback function defined in your subclass of Listener.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * To access frames of tracking data as they become available:}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * 1. Implement a subclass of the Listener class and override the}
\PYG{c+cm}{   *    Listener::onFrame() function.}
\PYG{c+cm}{   * 2. In your Listener::onFrame() function, call the Controller::frame()}
\PYG{c+cm}{   *    function to access the newest frame of tracking data.}
\PYG{c+cm}{   * 3. To start receiving frames, create a Controller object and add an instance}
\PYG{c+cm}{   *    of the Listener subclass to the Controller::addListener() function.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * When an instance of a Listener subclass is added to a Controller object,}
\PYG{c+cm}{   * it calls the Listener::onInit() function when the listener is ready for use.}
\PYG{c+cm}{   * When a connection is established between the controller and the Leap Motion software,}
\PYG{c+cm}{   * the controller calls the Listener::onConnect() function. At this point, your}
\PYG{c+cm}{   * application will start receiving frames of data. The controller calls the}
\PYG{c+cm}{   * Listener::onFrame() function each time a new frame is available. If the}
\PYG{c+cm}{   * controller loses its connection with the Leap Motion software or device for any}
\PYG{c+cm}{   * reason, it calls the Listener::onDisconnect() function. If the listener is}
\PYG{c+cm}{   * removed from the controller or the controller is destroyed, it calls the}
\PYG{c+cm}{   * Listener::onExit() function. At that point, unless the listener is added to}
\PYG{c+cm}{   * another controller again, it will no longer receive frames of tracking data.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * The Controller object is multithreaded and calls the Listener functions on}
\PYG{c+cm}{   * its own thread, not on an application thread.}
\PYG{c+cm}{   * @since 1.0}
\PYG{c+cm}{   */}
  \PYG{k}{class} \PYG{n+nc}{LEAP\PYGZus{}EXPORT\PYGZus{}CLASS} \PYG{n+nl}{Controller} \PYG{p}{:} \PYG{k}{public} \PYG{n}{Interface} \PYG{p}{\PYGZob{}}
  \PYG{k}{public}\PYG{o}{:}
    \PYG{c+c1}{// For internal use only.}
    \PYG{n}{Controller}\PYG{p}{(}\PYG{n}{ControllerImplementation}\PYG{o}{*}\PYG{p}{);}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Constructs a Controller object.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * When creating a Controller object, you may optionally pass in a}
\PYG{c+cm}{     * reference to an instance of a subclass of Leap::Listener. Alternatively,}
\PYG{c+cm}{     * you may add a listener using the Controller::addListener() function.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n+nf}{Controller}\PYG{p}{();}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{virtual} \PYG{o}{\PYGZti{}}\PYG{n}{Controller}\PYG{p}{();}
    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Constructs a Controller object.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * When creating a Controller object, you may optionally pass in a}
\PYG{c+cm}{     * reference to an instance of a subclass of Leap::Listener. Alternatively,}
\PYG{c+cm}{     * you may add a listener using the Controller::addListener() function.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Controller\PYGZus{}Controller.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param listener An instance of Leap::Listener implementing the callback}
\PYG{c+cm}{     * functions for the Leap Motion events you want to handle in your application.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n+nf}{Controller}\PYG{p}{(}\PYG{n}{Listener}\PYG{o}{\PYGZam{}} \PYG{n}{listener}\PYG{p}{);}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Reports whether this Controller is connected to the Leap Motion service and}
\PYG{c+cm}{     * the Leap Motion hardware is plugged in.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * When you first create a Controller object, isConnected() returns false.}
\PYG{c+cm}{     * After the controller finishes initializing and connects to the Leap Motion}
\PYG{c+cm}{     * software and if the Leap Motion hardware is plugged in, isConnected() returns true.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * You can either handle the onConnect event using a Listener instance or}
\PYG{c+cm}{     * poll the isConnected() function if you need to wait for your}
\PYG{c+cm}{     * application to be connected to the Leap Motion software before performing some other}
\PYG{c+cm}{     * operation.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Controller\PYGZus{}isConnected.txt}
\PYG{c+cm}{     * @returns True, if connected; false otherwise.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{n+nf}{isConnected}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Reports whether your application has a connection to the Leap Motion}
\PYG{c+cm}{     * daemon/service. Can be true even if the Leap Motion hardware is not available.}
\PYG{c+cm}{     * @since 1.2}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{n+nf}{isServiceConnected}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Reports whether this application is the focused, foreground application.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * By default, your application only receives tracking information from}
\PYG{c+cm}{     * the Leap Motion controller when it has the operating system input focus.}
\PYG{c+cm}{     * To receive tracking data when your application is in the background,}
\PYG{c+cm}{     * the background frames policy flag must be set.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Controller\PYGZus{}hasFocus.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns True, if application has focus; false otherwise.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @see Controller::setPolicyFlags()}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{n+nf}{hasFocus}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The supported controller policies.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * The supported policy flags are:}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * **POLICY\PYGZus{}BACKGROUND\PYGZus{}FRAMES** \PYGZhy{}\PYGZhy{} requests that your application receives frames}
\PYG{c+cm}{     *   when it is not the foreground application for user input.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     *   The background frames policy determines whether an application}
\PYG{c+cm}{     *   receives frames of tracking data while in the background. By}
\PYG{c+cm}{     *   default, the Leap Motion  software only sends tracking data to the foreground application.}
\PYG{c+cm}{     *   Only applications that need this ability should request the background}
\PYG{c+cm}{     *   frames policy. The \PYGZdq{}Allow Background Apps\PYGZdq{} checkbox must be enabled in the}
\PYG{c+cm}{     *   Leap Motion Control Panel or this policy will be denied.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * **POLICY\PYGZus{}IMAGES** \PYGZhy{}\PYGZhy{} request that your application receives images from the}
\PYG{c+cm}{     *   device cameras. The \PYGZdq{}Allow Images\PYGZdq{} checkbox must be enabled in the}
\PYG{c+cm}{     *   Leap Motion Control Panel or this policy will be denied.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     *   The images policy determines whether an application receives image data from}
\PYG{c+cm}{     *   the Leap Motion sensors which each frame of data. By default, this data is}
\PYG{c+cm}{     *   not sent. Only applications that use the image data should request this policy.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * **POLICY\PYGZus{}OPTIMIZE\PYGZus{}HMD** \PYGZhy{}\PYGZhy{} request that the tracking be optimized for head\PYGZhy{}mounted}
\PYG{c+cm}{     *   tracking.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     *   The optimize HMD policy improves tracking in situations where the Leap}
\PYG{c+cm}{     *   Motion hardware is attached to a head\PYGZhy{}mounted display. This policy is}
\PYG{c+cm}{     *   not granted for devices that cannot be mounted to an HMD, such as}
\PYG{c+cm}{     *   Leap Motion controllers embedded in a laptop or keyboard.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Some policies can be denied if the user has disabled the feature on}
\PYG{c+cm}{     * their Leap Motion control panel.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{k}{enum} \PYG{n}{PolicyFlag} \PYG{p}{\PYGZob{}}
      \PYG{c+cm}{/**}
\PYG{c+cm}{       * The default policy.}
\PYG{c+cm}{       * @since 1.0}
\PYG{c+cm}{       */}
      \PYG{n}{POLICY\PYGZus{}DEFAULT} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,}
      \PYG{c+cm}{/**}
\PYG{c+cm}{       * Receive background frames.}
\PYG{c+cm}{       * @since 1.0}
\PYG{c+cm}{       */}
      \PYG{n}{POLICY\PYGZus{}BACKGROUND\PYGZus{}FRAMES} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{),}

      \PYG{c+cm}{/**}
\PYG{c+cm}{       * Receive raw images from sensor cameras.}
\PYG{c+cm}{       * @since 2.1.0}
\PYG{c+cm}{       */}
      \PYG{n}{POLICY\PYGZus{}IMAGES} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+m+mi}{1}\PYG{p}{),}

      \PYG{c+cm}{/**}
\PYG{c+cm}{       * Optimize the tracking for head\PYGZhy{}mounted device.}
\PYG{c+cm}{       * @since 2.1.2}
\PYG{c+cm}{       */}
      \PYG{n}{POLICY\PYGZus{}OPTIMIZE\PYGZus{}HMD} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+m+mi}{2}\PYG{p}{),}

\PYG{c+cp}{\PYGZsh{}ifdef SWIGCSHARP}
      \PYG{c+c1}{// deprecated}
      \PYG{n}{POLICYDEFAULT} \PYG{o}{=} \PYG{n}{POLICY\PYGZus{}DEFAULT}\PYG{p}{,}
      \PYG{n}{POLICYBACKGROUNDFRAMES} \PYG{o}{=} \PYG{n}{POLICY\PYGZus{}BACKGROUND\PYGZus{}FRAMES}\PYG{p}{,}
\PYG{c+cp}{\PYGZsh{}endif}
    \PYG{p}{\PYGZcb{};}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * This function has been deprecated. Use isPolicySet() instead.}
\PYG{c+cm}{     * @deprecated 2.1.6}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{PolicyFlag} \PYG{n+nf}{policyFlags}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * This function has been deprecated. Use setPolicy() and clearPolicy() instead.}
\PYG{c+cm}{     * @deprecated 2.1.6}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{void} \PYG{n+nf}{setPolicyFlags}\PYG{p}{(}\PYG{n}{PolicyFlag} \PYG{n}{flags}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Requests setting a policy.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * A request to change a policy is subject to user approval and a policy}
\PYG{c+cm}{     * can be changed by the user at any time (using the Leap Motion settings dialog).}
\PYG{c+cm}{     * The desired policy flags must be set every time an application runs.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Policy changes are completed asynchronously and, because they are subject}
\PYG{c+cm}{     * to user approval or system compatibility checks, may not complete successfully. Call}
\PYG{c+cm}{     * Controller::isPolicySet() after a suitable interval to test whether}
\PYG{c+cm}{     * the change was accepted.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Controller\PYGZus{}setPolicy.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param policy A PolicyFlag value indicating the policy to request.}
\PYG{c+cm}{     * @since 2.1.6}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{void} \PYG{n+nf}{setPolicy}\PYG{p}{(}\PYG{n}{PolicyFlag} \PYG{n}{policy}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Requests clearing a policy.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Policy changes are completed asynchronously and, because they are subject}
\PYG{c+cm}{     * to user approval or system compatibility checks, may not complete successfully. Call}
\PYG{c+cm}{     * Controller::isPolicySet() after a suitable interval to test whether}
\PYG{c+cm}{     * the change was accepted.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Controller\PYGZus{}clearPolicy.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param flags A PolicyFlag value indicating the policy to request.}
\PYG{c+cm}{     * @since 2.1.6}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{void} \PYG{n+nf}{clearPolicy}\PYG{p}{(}\PYG{n}{PolicyFlag} \PYG{n}{policy}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Gets the active setting for a specific policy.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Keep in mind that setting a policy flag is asynchronous, so changes are}
\PYG{c+cm}{     * not effective immediately after calling setPolicyFlag(). In addition, a}
\PYG{c+cm}{     * policy request can be declined by the user. You should always set the}
\PYG{c+cm}{     * policy flags required by your application at startup and check that the}
\PYG{c+cm}{     * policy change request was successful after an appropriate interval.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * If the controller object is not connected to the Leap Motion software, then the default}
\PYG{c+cm}{     * state for the selected policy is returned.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Controller\PYGZus{}isPolicySet.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param flags A PolicyFlag value indicating the policy to query.}
\PYG{c+cm}{     * @returns A boolean indicating whether the specified policy has been set.}
\PYG{c+cm}{     * @since 2.1.6}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{n+nf}{isPolicySet}\PYG{p}{(}\PYG{n}{PolicyFlag} \PYG{n}{policy}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Adds a listener to this Controller.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * The Controller dispatches Leap Motion events to each associated listener. The}
\PYG{c+cm}{     * order in which listener callback functions are invoked is arbitrary. If}
\PYG{c+cm}{     * you pass a listener to the Controller\PYGZsq{}s constructor function, it is}
\PYG{c+cm}{     * automatically added to the list and can be removed with the}
\PYG{c+cm}{     * Controller::removeListener() function.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Controller\PYGZus{}addListener.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * The Controller does not keep a strong reference to the Listener instance.}
\PYG{c+cm}{     * Ensure that you maintain a reference until the listener is removed from}
\PYG{c+cm}{     * the controller.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param listener A subclass of Leap::Listener implementing the callback}
\PYG{c+cm}{     * functions for the Leap Motion events you want to handle in your application.}
\PYG{c+cm}{     * @returns Whether or not the listener was successfully added to the list}
\PYG{c+cm}{     * of listeners.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{n+nf}{addListener}\PYG{p}{(}\PYG{n}{Listener}\PYG{o}{\PYGZam{}} \PYG{n}{listener}\PYG{p}{);}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Remove a listener from the list of listeners that will receive Leap Motion}
\PYG{c+cm}{     * events. A listener must be removed if its lifetime is shorter than the}
\PYG{c+cm}{     * controller to which it is listening.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Controller\PYGZus{}removeListener.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param listener The listener to remove.}
\PYG{c+cm}{     * @returns Whether or not the listener was successfully removed from the}
\PYG{c+cm}{     * list of listeners.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{n+nf}{removeListener}\PYG{p}{(}\PYG{n}{Listener}\PYG{o}{\PYGZam{}} \PYG{n}{listener}\PYG{p}{);}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Returns a frame of tracking data from the Leap Motion software. Use the optional}
\PYG{c+cm}{     * history parameter to specify which frame to retrieve. Call frame() or}
\PYG{c+cm}{     * frame(0) to access the most recent frame; call frame(1) to access the}
\PYG{c+cm}{     * previous frame, and so on. If you use a history value greater than the}
\PYG{c+cm}{     * number of stored frames, then the controller returns an invalid frame.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Controller\PYGZus{}Frame\PYGZus{}1.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * You can call this function in your Listener implementation to get frames at the}
\PYG{c+cm}{     * Leap Motion frame rate:}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Controller\PYGZus{}Listener\PYGZus{}onFrame.txt}

\PYG{c+cm}{     * @param history The age of the frame to return, counting backwards from}
\PYG{c+cm}{     * the most recent frame (0) into the past and up to the maximum age (59).}
\PYG{c+cm}{     * @returns The specified frame; or, if no history parameter is specified,}
\PYG{c+cm}{     * the newest frame. If a frame is not available at the specified history}
\PYG{c+cm}{     * position, an invalid Frame is returned.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Frame} \PYG{n+nf}{frame}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{history} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The most recent set of images from the Leap Motion cameras.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Controller\PYGZus{}images.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Depending on timing and the current processing frame rate, the images}
\PYG{c+cm}{     * obtained with this function can be newer than images obtained from}
\PYG{c+cm}{     * the current frame of tracking data.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @return An ImageList object containing the most recent camera images.}
\PYG{c+cm}{     * @since 2.2.1}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{ImageList} \PYG{n+nf}{images}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Returns a Config object, which you can use to query the Leap Motion system for}
\PYG{c+cm}{     * configuration information.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Controller\PYGZus{}config.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The Controller\PYGZsq{}s Config object.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Config} \PYG{n+nf}{config}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * The list of currently attached and recognized Leap Motion controller devices.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * The Device objects in the list describe information such as the range and}
\PYG{c+cm}{     * tracking volume.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Controller\PYGZus{}devices.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Currently, the Leap Motion Controller only allows a single active device at a time,}
\PYG{c+cm}{     * however there may be multiple devices physically attached and listed here.  Any active}
\PYG{c+cm}{     * device(s) are guaranteed to be listed first, however order is not determined beyond that.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @returns The list of Leap Motion controllers.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{DeviceList} \PYG{n+nf}{devices}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/*}
\PYG{c+cm}{     * Deprecated as of version 1.2.}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{ScreenList} \PYG{n+nf}{locatedScreens}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/* For internal use only. */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{BugReport} \PYG{n+nf}{bugReport}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Enables or disables reporting of a specified gesture type.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * By default, all gesture types are disabled. When disabled, gestures of the}
\PYG{c+cm}{     * disabled type are never reported and will not appear in the frame}
\PYG{c+cm}{     * gesture list.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Controller\PYGZus{}enableGesture.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * As a performance optimization, only enable recognition for the types}
\PYG{c+cm}{     * of movements that you use in your application.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param type The type of gesture to enable or disable. Must be a}
\PYG{c+cm}{     * member of the Gesture::Type enumeration.}
\PYG{c+cm}{     * @param enable True, to enable the specified gesture type; False,}
\PYG{c+cm}{     * to disable.}
\PYG{c+cm}{     * @see Controller::isGestureEnabled()}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{void} \PYG{n+nf}{enableGesture}\PYG{p}{(}\PYG{n}{Gesture}\PYG{o}{::}\PYG{n}{Type} \PYG{n}{type}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{n}{enable} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Reports whether the specified gesture type is enabled.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Controller\PYGZus{}isGestureEnabled.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param type The type of gesture to check; a member of the Gesture::Type enumeration.}
\PYG{c+cm}{     * @returns True, if the specified type is enabled; false, otherwise.}
\PYG{c+cm}{     * @see Controller::enableGesture()}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{bool} \PYG{n+nf}{isGestureEnabled}\PYG{p}{(}\PYG{n}{Gesture}\PYG{o}{::}\PYG{n}{Type} \PYG{n}{type}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Note: This class is an experimental API for internal use only. It may be}
\PYG{c+cm}{     * removed without warning.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Returns information about the currently detected quad in the scene.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Controller\PYGZus{}trackedQuad.txt}
\PYG{c+cm}{     * If no quad is being tracked, then an invalid TrackedQuad is returned.}
\PYG{c+cm}{     * @since 2.2.6}
\PYG{c+cm}{     **/}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{TrackedQuad} \PYG{n+nf}{trackedQuad}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Returns a timestamp value as close as possible to the current time.}
\PYG{c+cm}{     * Values are in microseconds, as with all the other timestamp values.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @since 2.2.7}
\PYG{c+cm}{     **/}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k+kt}{int64\PYGZus{}t} \PYG{n+nf}{now}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}
  \PYG{p}{\PYGZcb{};}

  \PYG{c+cm}{/**}
\PYG{c+cm}{   * The Listener class defines a set of callback functions that you can}
\PYG{c+cm}{   * override in a subclass to respond to events dispatched by the Controller object.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * To handle Leap Motion events, create an instance of a Listener subclass and assign}
\PYG{c+cm}{   * it to the Controller instance. The Controller calls the relevant Listener}
\PYG{c+cm}{   * callback function when an event occurs, passing in a reference to itself.}
\PYG{c+cm}{   * You do not have to implement callbacks for events you do not want to handle.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * The Controller object calls these Listener functions from a thread created}
\PYG{c+cm}{   * by the Leap Motion library, not the thread used to create or set the Listener instance.}
\PYG{c+cm}{   * @since 1.0}
\PYG{c+cm}{   */}
  \PYG{k}{class} \PYG{n+nc}{LEAP\PYGZus{}EXPORT\PYGZus{}CLASS} \PYG{n}{Listener} \PYG{p}{\PYGZob{}}
  \PYG{k}{public}\PYG{o}{:}
    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Constructs a Listener object.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{n}{Listener}\PYG{p}{()} \PYG{p}{\PYGZob{}\PYGZcb{}}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Destroys this Listener object.}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{virtual} \PYG{o}{\PYGZti{}}\PYG{n}{Listener}\PYG{p}{()} \PYG{p}{\PYGZob{}\PYGZcb{}}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Called once, when this Listener object is newly added to a Controller.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Listener\PYGZus{}onInit.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param controller The Controller object invoking this callback function.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n}{onInit}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Controller}\PYG{o}{\PYGZam{}}\PYG{p}{)} \PYG{p}{\PYGZob{}\PYGZcb{}}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Called when the Controller object connects to the Leap Motion software and}
\PYG{c+cm}{     * the Leap Motion hardware device is plugged in,}
\PYG{c+cm}{     * or when this Listener object is added to a Controller that is already connected.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * When this callback is invoked, Controller::isServiceConnected is true,}
\PYG{c+cm}{     * Controller::devices() is not empty, and, for at least one of the Device objects in the list,}
\PYG{c+cm}{     * Device::isStreaming() is true.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Listener\PYGZus{}onConnect.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param controller The Controller object invoking this callback function.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n}{onConnect}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Controller}\PYG{o}{\PYGZam{}}\PYG{p}{)} \PYG{p}{\PYGZob{}\PYGZcb{}}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Called when the Controller object disconnects from the Leap Motion software or}
\PYG{c+cm}{     * the Leap Motion hardware is unplugged.}
\PYG{c+cm}{     * The controller can disconnect when the Leap Motion device is unplugged, the}
\PYG{c+cm}{     * user shuts the Leap Motion software down, or the Leap Motion software encounters an}
\PYG{c+cm}{     * unrecoverable error.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Listener\PYGZus{}onDisconnect.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Note: When you launch a Leap\PYGZhy{}enabled application in a debugger, the}
\PYG{c+cm}{     * Leap Motion library does not disconnect from the application. This is to allow}
\PYG{c+cm}{     * you to step through code without losing the connection because of time outs.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param controller The Controller object invoking this callback function.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n}{onDisconnect}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Controller}\PYG{o}{\PYGZam{}}\PYG{p}{)} \PYG{p}{\PYGZob{}\PYGZcb{}}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Called when this Listener object is removed from the Controller}
\PYG{c+cm}{     * or the Controller instance is destroyed.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Listener\PYGZus{}onExit.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param controller The Controller object invoking this callback function.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n}{onExit}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Controller}\PYG{o}{\PYGZam{}}\PYG{p}{)} \PYG{p}{\PYGZob{}\PYGZcb{}}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Called when a new frame of hand and finger tracking data is available.}
\PYG{c+cm}{     * Access the new frame data using the Controller::frame() function.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Listener\PYGZus{}onFrame.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Note, the Controller skips any pending onFrame events while your}
\PYG{c+cm}{     * onFrame handler executes. If your implementation takes too long to return,}
\PYG{c+cm}{     * one or more frames can be skipped. The Controller still inserts the skipped}
\PYG{c+cm}{     * frames into the frame history. You can access recent frames by setting}
\PYG{c+cm}{     * the history parameter when calling the Controller::frame() function.}
\PYG{c+cm}{     * You can determine if any pending onFrame events were skipped by comparing}
\PYG{c+cm}{     * the ID of the most recent frame with the ID of the last received frame.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param controller The Controller object invoking this callback function.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n}{onFrame}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Controller}\PYG{o}{\PYGZam{}}\PYG{p}{)} \PYG{p}{\PYGZob{}\PYGZcb{}}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Called when this application becomes the foreground application.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Only the foreground application receives tracking data from the Leap}
\PYG{c+cm}{     * Motion Controller. This function is only called when the controller}
\PYG{c+cm}{     * object is in a connected state.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Listener\PYGZus{}onFocusGained.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param controller The Controller object invoking this callback function.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n}{onFocusGained}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Controller}\PYG{o}{\PYGZam{}}\PYG{p}{)} \PYG{p}{\PYGZob{}\PYGZcb{}}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Called when this application loses the foreground focus.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Only the foreground application receives tracking data from the Leap}
\PYG{c+cm}{     * Motion Controller. This function is only called when the controller}
\PYG{c+cm}{     * object is in a connected state.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Listener\PYGZus{}onFocusLost.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param controller The Controller object invoking this callback function.}
\PYG{c+cm}{     * @since 1.0}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n}{onFocusLost}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Controller}\PYG{o}{\PYGZam{}}\PYG{p}{)} \PYG{p}{\PYGZob{}\PYGZcb{}}

    \PYG{c+c1}{// onServiceConnect/onServiceDisconnect are for connection established/lost.}
    \PYG{c+c1}{// in normal course of events onServiceConnect will get called once after onInit}
    \PYG{c+c1}{// and onServiceDisconnect will not get called. disconnect notification only happens}
    \PYG{c+c1}{// if service stops running or something else bad happens to disconnect controller from service.}
    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Called when the Leap Motion daemon/service connects to your application Controller.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Listener\PYGZus{}onServiceConnect.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param controller The Controller object invoking this callback function.}
\PYG{c+cm}{     * @since 1.2}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n}{onServiceConnect}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Controller}\PYG{o}{\PYGZam{}}\PYG{p}{)} \PYG{p}{\PYGZob{}\PYGZcb{}}
    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Called if the Leap Motion daemon/service disconnects from your application Controller.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * Normally, this callback is not invoked. It is only called if some external event}
\PYG{c+cm}{     * or problem shuts down the service or otherwise interrupts the connection.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Listener\PYGZus{}onServiceDisconnect.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param controller The Controller object invoking this callback function.}
\PYG{c+cm}{     * @since 1.2}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n}{onServiceDisconnect}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Controller}\PYG{o}{\PYGZam{}}\PYG{p}{)} \PYG{p}{\PYGZob{}\PYGZcb{}}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Called when a Leap Motion controller plugged in, unplugged, or the device changes state.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * State changes include changes in frame rate and entering or leaving \PYGZdq{}robust\PYGZdq{} mode.}
\PYG{c+cm}{     * Note that there is currently no way to query whether a device is in robust mode.}
\PYG{c+cm}{     * You can use Frame::currentFramerate() to get the framerate.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Listener\PYGZus{}onDeviceChange.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param controller The Controller object invoking this callback function.}
\PYG{c+cm}{     * @since 1.2}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n}{onDeviceChange}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Controller}\PYG{o}{\PYGZam{}}\PYG{p}{)} \PYG{p}{\PYGZob{}\PYGZcb{}}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Called when new images are available.}
\PYG{c+cm}{     * Access the new frame data using the Controller::images() function.}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * \PYGZbs{}include Listener\PYGZus{}onImages.txt}
\PYG{c+cm}{     *}
\PYG{c+cm}{     * @param controller The Controller object invoking this callback function.}
\PYG{c+cm}{     * @since 2.2.1}
\PYG{c+cm}{     */}
    \PYG{n}{LEAP\PYGZus{}EXPORT} \PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n}{onImages}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Controller}\PYG{o}{\PYGZam{}}\PYG{p}{)} \PYG{p}{\PYGZob{}\PYGZcb{}}

  \PYG{p}{\PYGZcb{};}
\PYG{p}{\PYGZcb{}}

\PYG{c+cp}{\PYGZsh{}endif }\PYG{c+c1}{// \PYGZus{}\PYGZus{}Leap\PYGZus{}h\PYGZus{}\PYGZus{}}
\end{Verbatim}
